---
layout: article
tags: Leetcode Python
title: Leetcode problems 221-240
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 221 to 240, writing in Python.

<!--more-->

## 221.Maximal Square  (Dynamic)

[Problem link](https://leetcode.com/problems/maximal-square/)

- My approach

My idea is brute force. Traverse the matrix and check every element if they can make a square.

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        b = []
        for m in matrix:
            b += m
        if set(b) == {'0'}:
            return 0
        
        m = len(matrix)
        n = len(matrix[0])
        
        # Check if a square can be constitued by current line matrix[top][left:right]
        def helper(top, left, right):
            for k in range(right-left-1):
                if top+k+1 >= m:
                    return 0
                if '0' in set(matrix[top+k+1][left:right]):
                    return 0
            return (right-left)**2
                
        res = 1
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    right = j
                    # When finding a '1', find the most '1' on current row, this maybe the top edge of a square
                    while right < n and right-j < m-i and matrix[i][right] == '1':                      
                        right += 1
                        if right-j <= m-i:
                            curr_area = helper(i, j, right)
                        res = max(res, curr_area)
        
        return res
```

- Other's approach

The best method to solve this problem is dynamic programming.

There are two approached form official solution.

1.m*n dp

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        m = len(matrix)
        n = len(matrix[0])
        
        res = 0
        dp = []
        for i in range(m+1):
            dp.append([0]*(n+1))
        
        for i in range(1, m+1):
            for j in range(1, n+1):
                if matrix[i-1][j-1] == '1':
                    # The key point is here
                    # Current element stands for the right-bottom corner of a square, and its value is the length of side
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    res = max(res, dp[i][j])
                else:
                    dp[i][j] = 0
                    
        return res*res
```

2. n dp

We can set the dp from 2D to 1D. And make dp[i] stands for dp[i-1][j] in 2D, dp[i-1] stands for dp[i][j-1], and set a variable prev stands for dp[i-1][j-1].

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        m = len(matrix)
        n = len(matrix[0])
        
        res = 0
        prev = 0
        dp = [0]*(n+1)
        for i in range(1, m+1):
            for j in range(1, n+1):
                temp = dp[j]
                if matrix[i-1][j-1] == '1':
                    # The principle is the same as 2D
                    dp[j] = min(prev, dp[j], dp[j-1]) + 1
                    res = max(res, dp[j])
                else:
                    dp[j] = 0
                prev = temp
        return res*res
```

For more explinations, please see [official solution](https://leetcode.com/problems/maximal-square/solution/)


## 222.Count Complete Tree Nodes  (Recursing)

[Problem link](https://leetcode.com/problems/count-complete-tree-nodes/)

- My approach

My idea is doing level order traversal and record the levels.

Because only the last lavel may be uncomplete, the answer is the number of last level then plus 2^(level-1)-1.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        stack = [root]
        level = 0
        while stack:
            curr = []
            # The number of last level
            last_level = len(stack)
            for n in stack:
                if not n.left:
                    break
                curr.append(n.left)
                if not n.right:
                    break
                curr.append(n.right)
            stack = curr
            level += 1
        return 2**(level-1)-1+last_level
```

- Other's approach

This problem is better using recursing method.

Here is an example

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        
        if not root:
            return 0
        l_level = 1
        l = root.left
        while l:
            l = l.left
            l_level+=1
        r_level = 1
        r = root.right
        while r:
            r = r.right
            r_level+=1
        # Only if current sub tree is a complete binary tree or a leaf node can return here
        if l_level == r_level:
            return int(math.pow(2,l_level)-1)
        
        # 1 stands for the root node, and number of all the nodes equals to root + left child + right child
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
            
```

