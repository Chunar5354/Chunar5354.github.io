---
layout: article
tags: Leetcode Python
title: Leetcode problems 1-20
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 1 to 20, writing in Python.

<!--more-->

## 1.Two Sum

[题目链接](https://leetcode.com/problems/two-sum/)

第一次在LeetCode刷题，上来就hardcode了一个：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        return_list = []
        for i in range(len(nums)):
            first_num = nums[i]
            for j in range(len(nums)):
                if j != i:
                    if first_num + nums[j] == target:
                        return_list.append(i)
                        return_list.append(j)
                        return return_list
                    else:
                        pass
```

少量数据测试的时候完全没问题（甚至还最短），但是submit的时候就超时了

第二次用了`enumerate()`函数，成功通过了，但成绩不太理想：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, fir in enumerate(nums):
            sec = target - fir
            if sec in nums and nums.index(sec) != i:
                return [i, nums.index(sec)]
            else:
                pass
```

问题应该是出在了多次进行的`index()`查找索引值上

最后看了别人的solutions，最快的方法是使用hash表（Python中的dict）：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        h = {}
        for i, num in enumerate(nums):
            n = target - num
            if n not in h:
                h[num] = i
            else:
                return [h[n], i]
```

### 结论

对于这种需要查找索引值以及数值的问题，在数据量大的情况下，应该优先考虑使用类字典的存储方式

### 知识点

hashmap：java中的一种数据结构，可类比于python中的字典结构

hashmap中元素的存储位置是由key的hashcode和hashmap的长度计算出来的[参考](https://zhuanlan.zhihu.com/p/31610616)

hashmap的扩展长度必须是2的n次方（为计算存储位置考虑）

- 区别：
    - 1.hashmap的初始长度，在java中是16，python中是8
    - 2.在java中，hashmap的结构是`数组+链表`，当存在冲突的时候，会将新元素存放在该地址对应的链表中的下一个结点；在python中使用的
    是开放寻址法[参考](https://www.cnblogs.com/lianzhilei/p/9275115.html)，存在冲突时会继续向下扩展存储单元，找到新的合适地址
    

## 2.Add Two Numbers

[题目链接](https://leetcode.com/problems/add-two-numbers/)

仍然是自己hardcode了一个（其实也写了好久），对数据结构还是不太熟悉，要在Python中实现一个链表，自己首先想到的还是借助Python的对象，
最后是使用列表实现的，当然成绩很不理想啦：
```python
class Solution:
    def getlist(self, l, l_list):
        if l.next != None:
            self.getlist(l.next, l_list)
            l_list.append(l.val)
        else:
            l_list.append(l.val)
        return l_list   
    
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        l1_num = []
        l2_num = []
        sum = 0
        l1_num = self.getlist(l1, l1_num)
        l2_num = self.getlist(l2, l2_num)
        n = max(len(l1_num), len(l2_num))
        for i in range(n):
            if len(l1_num) > 0:
                l1_val = l1_num.pop(-1)
            else:
                l1_val = 0
            if len(l2_num) > 0:
                l2_val = l2_num.pop(-1)
            else:
                l2_val = 0
            sum += (l1_val + l2_val) * 10 ** (i)
        if sum == 0:
            return ListNode(0)
        else:
            s_sum = str(sum)
            res = {}
            for i in range(len(s_sum)):
                if i == 0:
                    res[i] = ListNode(int(s_sum[i]))
                    res[i].next = None
                else:
                    res[i] = ListNode(int(s_sum[i]))
                    res[i].next = res[i-1]
            return res[len(s_sum)-1]
```
其实绕了很多弯路，比如把输入的链表顺序翻过来倒过去（为了实现正常顺序数字相加），其实就是一个进位的问题，把进位位存下来就好了

参考了一个别人的答案：
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        prenode = ListNode(0)
        lastnode = prenode  # 头结点
        val = 0
        while val or l1 or l2:
            # divmod() 返回商和余数
            val, cur = divmod(val + (l1.val if l1 else 0) + (l2.val if l2 else 0), 10)
            # 每次计算后，将结果作为一个新的结点插入链表尾部
            lastnode.next = ListNode(cur)
            lastnode = lastnode.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return prenode.next
```
这个方案好在使用了链表的头结点，用它作为返回结果，这样就可以在每次运算中顺序在链表后插入新结点

### 结论

- 1. 对于结果要返回链表的程序，使用`头结点`是一个好的选择
- 2. 要活用链表的插入等操作

### 知识点

- 1.`divmod(a, b)`返回a/b的商和余数
- 2.`a // b`结果为a/b的商取整数
- 3.在Python中构建一个链表：
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x       # 数据域
        self.next = None   # 指针域
```

## 3.Longest Substring Without Repeating Characters

[题目链接](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

这个自己没做出来，写的代码都超时了，想的方法是比较傻的挨个遍历，首先用集合找到所有出现的字符，
然后字符串的最大长度就是字符数，并按照长度逐个遍历，最终执行超时了：
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int: 
        m_list = []
        s_set = set(s)
        n = len(s_set)
        if n == len(s):
            return n
        else:
            while n > 0:
                for i in range(len(s) - n + 1):
                    s_sub = s[i: i+n]
                    print(i, n)
                    if len(set(s_sub)) == len(s_sub):
                        m_list.append(len(s_sub))
                n = n - 1
            return max(m_list)
```

然后优化的办法怎么也没想出来，就查看了其他人的答案，一个比较清晰的:
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int: 
        str_list = []
        max_length = 0

        for x in s:
            if x in str_list:
                # 每当出现重复字符的时候，结果字符串就从第一个重复字符串的下一个字符开始
                str_list = str_list[str_list.index(x)+1:]
            str_list.append(x)    
            # print(str_list)
            max_length = max(max_length, len(str_list))  # 中途记录最长的结果字符串
        return max_length
```

它顺序遍历所有字符，并存放在一个列表中，每当出现重复字符的时候，结果字符串就从第一个重复字符串的下一个字符开始，例如`abcda`，执行到第二个a的时候，
就将列表更新为`['b', 'c', 'd', 'a']`，列表中永远不会出现重复，并在途中记录结果字符串长度的最大值

还有一种更快速的方法，使用字典，实现的思想与上面类似：
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int: 
        dct = {}
        max_so_far = curr_max = start = 0
        for index, i in enumerate(s):   # 取字符和其对应的索引
            if i in dct and dct[i] >= start:   # 如果出现了重复元素
                max_so_far = max(max_so_far, curr_max)   # 记录最长字符串
                curr_max = index - dct[i]   # 长度为两个重复字符串之间的间隔
                start = dct[i] + 1   # start表示从第几个字符开始作为结果字符串，在判断的时候，出现的重复字符串如果在start之前就不算了
            else:
                curr_max += 1   # 如果字符没出现在dct中，结果字符串长度要加1
            dct[i] = index    # 把每个字符都存到dct中
        return max(max_so_far, curr_max)
```

它也是顺序遍历字符串，并按照`{value: index}`的格式将字符串的每个字符存放在一个字典中，每当出现重复字符，结果字符串的长度即为两个
重复字符串之间的`位置差`，并且使用了一个`start`变量来表示结果字符串的起始位置，如果在遍历中找到的重复字符串的位置在start之前，就忽略这个字符
并且在每一次遍历中都更新当前字符在字典中存储的索引值

### 结论

- 1.像这种查找多个元素的最大值问题，一般要在每一次的查找中进行比较，记录最大值
- 2.使用字典反向存储一个列表或者字符串的value和index的关系往往起到很好的作用
- 3.这个问题的关键是在每次出现重复字符的时候，要更新结果字符串的`第一个字符`


### 知识点

- 滑动窗口，类似于上面解法2中的列表，区间为[i, j]，当每次出现元素k与[i, j]中的元素相同的时候，窗口就变为[k+1, j]


## 4.Median Of Two Sorted Array

[题目链接](https://leetcode.com/problems/median-of-two-sorted-arrays/)

上来一看题目中要求了时间复杂度是O(log(m+n))，着实捏了一把汗，按照自己的想法：拼接字典然后重新排序，竟然一试就通过了：
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        nums1.extend(nums2)
        nums1.sort()
        n = len(nums1)
        if n % 2 == 0:
            return (nums1[int(n/2)] + nums1[int(n/2 -1)]) / 2
        else:
            return nums1[int((n-1)/2)]
```

不过成绩还是很差，看了官方的答案，好复杂，要把两个列表分别拆分再比较，结果运行时间比我的还长

找了一个其他人的比较快的答案：
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        sorted_joined = sorted(nums1 + nums2)
        if len(sorted_joined) % 2 == 0:
            index = int(len(sorted_joined) / 2)
            return (sorted_joined[index] + sorted_joined[index-1])/2
        else:
            index = (int(len(sorted_joined)/2))
            return sorted_joined
```

和我的做法几乎一模一样，只是拼接两个列表的时候他使用的是`+`，我用的是`entend()`函数。（把我自己的方法改成`+`之后速度也上去了...）

### 结论

- 1.两个列表拼接的方法中，`extend()`函数会循环遍历列表2的每个元素，并依次添加到列表1的末尾，在列表长度很大的时候，速度就会降低，表现不如
直接使用`+`直接拼接
- 2.列表排序的方法中，`list.sort()`要比`list2 = sorted(list1)`速度更快，原因可能是`list.sort()`是对原列表进行修改，而`list2 = sorted(list1)`
方法则要生成一个新的列表，更加耗费资源

### 知识点

- 1.O(log n)的时间复杂度：常见于`二分法`，每次去总长的一半进行分割，对于长度为n的序列，要查找到某一元素需要进行 2<sup>k</sup> = n， 
k = log<sub>2</sub> n 
次操作。  [参考](https://juejin.im/entry/593f56528d6d810058a355f4)


## 5.Longest Palindromic Substring

[题目链接](https://leetcode.com/problems/longest-palindromic-substring/)

一开始没读透`回文(palindromic)`的意思，顺着`Longest Substring Without Repeating Characters`这道题的思路写了。
发现错误之后又经过艰苦卓绝的奋斗，独立搞出来了，而且分数竟然很高（超过90%）：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        '''
        Set a dict, the structure is {char: [index1, index2, ...]}
        When finding a repeated char, check if the string between the same chars is palindromic
        '''
        res_dict = {}
        max_n = max_all = 0
        if len(s) > 0:
            max_s = s[0]
        else:
            return ''
        for index, val in enumerate(s):
            if val not in res_dict:
                res_dict[val] = [index]
            else:
                # add the index into dict
                res_dict[val].append(index)
                for i in range(len(res_dict[val])):
                    max_n = index - res_dict[val][i] + 1
                    cur_s = s[res_dict[val][i]: index+1]
                    if cur_s == cur_s[::-1]:
                        if max_n > max_all:
                            max_all = max_n
                            max_s = cur_s
                        break
        return max_s
```

思路是`找重复字符`，并将相同字符的每一个位置（索引值）存放在一个列表中，并使用`{char: [index1, index2, ...]}`结构的字典来存储，
每当找到重复的字符时，先判断两个最远重复字符（index1）之间的字符串是否为回文，如果不是，再判断第二远重复字符（index2），以此类推，
并在中途记录最长的回文字符串

后来又找了一个答案中最快的程序，研究一下没太懂（但是他比我的快10几倍），先把这个神仙程序记录下来：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) <= 1 or s[::-1] == s:
            return s
        start = 0
        max_len = 1
        
        for i in range(len(s)):
            i_odd = i - max_len -1
            i_even = i - max_len
            odd = s[i_odd:i+1]
            even = s[i_even:i+1]
            print(odd, even)
            if i_odd >= 0 and odd == odd[::-1]:  # 为什么长度要分加1和加2？
                max_len += 2
                start = i_odd
            if i_even >=0 and even == even[::-1]:
                max_len += 1
                start = i_even
        return s[start:start+max_len]
```

### 结论

- 找回文字符串，判断其正反向是否相等是一个好办法

### 知识点

- Python中倒序：通过`[::-1]`的方法，可以处理如字符串和列表等有序的序列，例如：
```python
a = 'abcd'
print(a[::-1])
# 结果为： dcba
```

也可以从中间某一元素开始倒序排列，`[2::-1]`表示从下标为2的元素开始倒序排列，例如：
```python
a = 'abcd'
print(a[2::-1])
# 结果为： cba
```

## 6.ZigZag Conversion

[题目链接](https://leetcode.com/problems/zigzag-conversion/)

又自然而然的想到了用字典储存列表的方法，将zigzag之后的每一行都存放在一个列表中，最后按顺序拼接在一起，关键在于计算每一行元素的共同特征：
```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        # 首先按照给出的行数numRows创建一个列表：{0: [], ... numRows: []}
        res_dict = {i: [] for i in range(numRows)}
        n = 2 * (numRows-1)  # 元素的特征之一是相邻的元素位置相差n（第一行和最后一行）
        for i in range(len(s)):
            do_fin = 0
            n1 = (i + n) % n
            # 除了第一行和最后一行，其他每一行的元素有两个序列，一个是从n1开头，一个是从n2开头，各自的间隔都是n
            # n2和n1的关系是 n2 = n - n1
            n2 = n - n1
            # 从左至右把每个元素插入对应的列表中
            if n1 in res_dict:
                res_dict[n1].append(s[i])
                do_fin = 1
            if n2 in res_dict and do_fin == 0:
                res_dict[n2].append(s[i])
        print(res_dict)
        res_list = []
        for key in res_dict:
            res_list += res_dict[key]
        return ''.join(res_list)
```

大方向没问题，基本上是一把过，但是成绩仍然不太理想（20%）

参考了高分代码，人家没有用索引值计算，而是比较机智的利用了zigzag的走向特征，创建了一个`方向`变量，其他的也是一次添加到列表中：
```python
class Solution:
    def convert(self, s, numRows):
        if numRows == 1:
            return s
        step = 1  # 表示zigzag的方向是向上走还是向下走
        pos = 1
        lines = {}
        for c in s:
            if pos not in lines:
                lines[pos] = c
            else:
                lines[pos] += c
            pos += step  # 走一步
            if pos==1 or pos==numRows:   # 如果走到头或走到尾，就改变方向
                step*=-1
        sol = ""
        for i in range(1, numRows):
            try:
                sol+=lines[i]
            except:
                return sol
        return sol
```

一个更快速的版本：
```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1 or numRows >= len(s):return s
        ret_res = [''] * numRows   # 他这里直接用列表存放了每一行的字符串
        i_b = 0
        for c in s:
            if i_b == 0:inc = 1  # 依然是方向
            elif i_b == numRows - 1:inc = -1  # 依然是方向
            ret_res[i_b] += c
            i_b += inc  # 走一步
        return ''.join(ret_res)
```

### 结论

- 对于zigzag这种来回循环的问题，引入一个`方向`的点子真是太赞了

### 知识点

- zigzag：之字形结构


## 7.Reverse Integer

[题目链接](https://leetcode.com/problems/reverse-integer/solution/)

今天终于与取得了不错的成绩：

>Runtime: 28 ms, faster than 99.36% of Python3 online submissions for Reverse Integer.   
Memory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Reverse Integer.

不过这题不算难，一下就想到了把数字转换成字符串再用列表排序，其实关键于列表倒序的算法`l.reverse()`，它是内置的：
```python
class Solution:
    def reverse(self, x: int) -> int:
    '''
    Convert int x into string x, split string into list, then reverse it
    '''
        if x > 2 ** 31 - 1 or x < - 2 ** 31 or x == 0:
            return 0
        if x > 0:
            l = [i for i in str(x)]
            l.reverse()
            res = int(''.join(l))
            if res > 2 ** 31 - 1:
                return 0
            else:
                return res
        else:
            l = [i for i in str(x)][1:]
            l.reverse()
            res = -int(''.join(l))
            if res < - 2 ** 31:
                return 0
            else:
                return res
```

看了官方的解答和其他人的一些答案，还有一种比较常见的方法是对这个整数逐位除以10取余：`n = x % 10`，然后从最低位开始反向相加：`res = res * 10 + n`

官方的java答案：
```python
class Solution {
    public int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            int pop = x % 10;
            x /= 10;
            // 判断是否溢出（这里的pop表示个位数字是否大于7或者小于-8，因为区间是[-2147483648, 2147483647]）
            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;
            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    }
}
```

### 结论

- 对于整数的操作，一个思路是`逐位取余`

### 知识点

- Python中的`list.reverse()`，源码没查到，但内部实现的方式可能是交换下标（因为和l.reverse()的方法提交之后运行的时间相同）：
```
l = []
n = len(l)
for i in range(n // 2):
    l[i], l[n-1-i] = l[n-1-i], l[i]
```


## 8.String To Integer Atoi

[题目链接](https://leetcode.com/problems/string-to-integer-atoi/)

这道题没啥知识点（官方连答案都没给），关键在于如何找到目标字符串：
```python
class Solution:
    def myAtoi(self, str: str) -> int:
        dig_s = ' -+0123456789'
        # start_i表示第一个出现`-+0123456789`中字符的位置
        # end_i表示start_i出现之后，最近的一个非数字字符出现的位置
        start_i = end_i = -1
        for i in range(len(str)):
            if str[i] not in dig_s and start_i == -1:
                return 0
            if str[i] not in dig_s[3:] and start_i != -1:
                end_i = i
                break
            if str[i] in dig_s[1:] and start_i == -1:
                start_i = i

        # 如果到最后都没有出现start_i和end_i
        if start_i == -1:
            return 0
        if end_i == -1:
            end_i = len(str)
            
        s = str[start_i:end_i]
        if s == '-' or s == '+':
            return 0
        n = int(s)
        if n >= 2147483647:
            return 2147483647
        if n <= -2147483648:
            return -2147483648
        return n
```

自己的答案超过了47%，还算可以

看了高分的答案，他用了一个比较巧妙的方法先去掉了开头的空格字符，然后对每个字符调用`int()`方法，通过抛出异常来检测目标字符，省去了多次遍历：
```python
class Solution:
    # 去掉字符串开头的空格
    def remove_ws(self, s):
        new_s = ""
        ignore_ws = True
        
        for char in s:
            if char != " ":
                ignore_ws = False
            
            if char == " " and ignore_ws == True:
                continue
                
            new_s += char
        return new_s
    
    def myAtoi(self, s: str) -> int:
        s = self.remove_ws(s)      
        
        is_negative = s.startswith("-")
        if is_negative or s.startswith("+"):
            s = s[1:]
        
        num_str = ""
        for i in s:
            try:
                int(i)  # 在遇到非数字字符时会出错，抛出异常，从而终止遍历
                num_str += i
            except ValueError:
                break
                
        if num_str == "":
            return 0
        
        num =  0 - int(num_str) if is_negative else int(num_str)
        
        if num < -2147483648:
            return -2147483648
        
        if num >= 2147483648:
            return 2147483647
        
        return num
```

### 结论

- 1.答案二中去掉开头空格字符的方法值得借鉴
- 2.有时候可以利用Python的异常机制

### 知识点

- `atoi()`是C语言中的一个函数，将字符串转换成整型


## 9.Palindrome Number

[题目链接](https://leetcode.com/problems/palindrome-number/)

这道题比较简单，如果用字符串的方法一行代码就搞定了:
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return str(x)==str(x)[::-1]
```

不过题目中给了一个提高项目：不使用字符串方法。那就逐位取余，再反向加和：
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        res = 0
        sou = x
        while sou > 0:
            # 取sou除以10的商和余数
            sou, rem = divmod(sou, 10)
            res = res * 10 + rem
        if res == x:
            return True
        else:
            return False
        # 其实后面的判断没有必要，对于返回值要求是bool的时候，可以直接return
        # return res == x
```

运行速度也很快，超过85%

不过官方解答中给出了一个更优化的方案：反向加和没必要加完整个数字，只要处理到数字长度的一半就可以了，因为回文数字后一半的倒置和前一半一定相等，
对于长度为奇数的数字，加完一半之后除以10去掉个位就好了：
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x == 0:
            return True
        if x < 0 or x % 10 == 0:
            return False
        res = 0
        while x > res:
            x, rem = divmod(x, 10)
            res = res * 10 + rem
        # 判断：前一半针对偶数长度的数字，后一半针对奇数长度
        return x == res or x == res // 10
```

### 结论

- 1.对于返回值为bool的函数，可以直接return表达式
- 2.对于回文，可以只取一半进行处理，节约资源



## 10.Regular Expression Matching  (Recursing method)

[题目链接](https://leetcode.com/problems/regular-expression-matching/)

这个题好难，要判断的条件太多了，整理一下：

依次对两个字符串进行遍历，在不超过原字符串长度的条件下，判断p中当前字符(p[j])的下一位是否为`*`
- 1 若为`*`，则有两种情况：
  - 1.1 `*`前面的字符在s中要重复出现，比如这种情况：
  ```
  s = 'aaaab'
  p = 'a*b'
  ```
  要判断`*`前面的字符和s中对应位置(s[i])的字符是否相等，如果相等（包括`*`前面的字符为`.`的情况），就对s[i+1:]和p[j:]再次进行判断（递归）
 
  - 1.2 `*`前面的字符在s中对应的位置没有，比如：
  ```
  s = 'aaaab'
  p = 'c*b'
  ```
  因为`*`符号表示它前面的字符又x个，而x可以为0，所以在这种情况下，要对s[i:]和p[j+2:]再次进行判断（递归）

- 2 若不为`*`，则要看s[i]与p[j]是否相等（包括`.`字符），如果相等，则从s[i+1:]和p[j+1:]继续判断（递归）；如果不相等，则函数结束，返回False

自己做的时候被绕蒙了，看了官方的答案，最优解是这个：
```python
class Solution(object):
    def isMatch(self, text, pattern):
        memo = {}
        # 嵌套了一个递归函数
        def dp(i, j):
            if (i, j) not in memo:
                # 如果字符串p已经遍历完，而s还没有，说明二者不匹配
                if j == len(pattern):
                    ans = i == len(text)
                else:
                    # 判断p中的字符和s中对应位置的字符是否相等，或为'.'
                    first_match = i < len(text) and pattern[j] in {text[i], '.'}
                    # 如果p的下一个字符是'*'
                    if j+1 < len(pattern) and pattern[j+1] == '*':
                        # dp(i, j+2)对应前面说的情况中的1.2
                        # dp(i+1, j)对应情况1.1
                        ans = dp(i, j+2) or first_match and dp(i+1, j)
                    else:
                        # dp(i+1, j+1)对应情况2
                        ans = first_match and dp(i+1, j+1)

                memo[i, j] = ans   # 为什么不把结果存在memo里面就要慢很多？
            return memo[i, j]

        return dp(0, 0)  # 从s[0], p[0]开始判断
```

这里有一个很有意思的现象，当把`memo[i, j] = ans`这一句注释掉，直接`return ans`的时候，运行的时间会极具增加（1756ms，而原本只有28ms）


## 11.Container With Most Water

[题目链接](https://leetcode.com/problems/container-with-most-water/)

这道题的原理很容易搞清，就是一个`底乘高`，但是自己写了两个版本，全都超时了

优化方法的原理可以看一下官方给出的这个[视频](https://leetcode.com/problems/container-with-most-water/solution/)，非常生动形象

思路大致为：
- 首先从两个端点开始计算，保存结果
- 然后将其中数值较大的那一个端点保留，取数值较小的点的下一个点继续进行计算
  - 因为类似于`木桶效应`的问题要取最短的一根计算容积，那么对于短的那一根来说，肯定是与它`距离最远`的点计算出来的容积是最大的，中间的那些点可以省略
- 依次逐个点进行计算，直到两个端点相遇

算法实现：
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        max_res = 0
        # l为左端点，r为右端点
        l = 0
        r = len(height) - 1
        while l < r:
            #3 取其中数值小的一个计算容积，并取数值较小点的下一个点继续计算
            if height[l] < height[r]:
                max_res = max(max_res, height[l] * (r - l))
                l += 1
            else:
                max_res = max(max_res, height[r] * (r - l))
                r -= 1
            
        return max_res
```

### 结论

- 1.多思考问题的本质，尽量减少遍历的次数
- 2.别再使用像：
```python
max_a = 0
if a > max_a:
    max_a = a
```
这种取最大值的方法了，直接`max(max_a, a)`多简洁


## 12.Integer To Roman

[题目链接](https://leetcode.com/problems/integer-to-roman/)

后面还有一个[Roman To Integer](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/RomanToInteger.md)，是这个题的反向

数字转换成罗马数字，本质上是数字和字符串的一一对应，只要掌握各自的规则再进行拼凑就可以了：
```python
class Solution:
    def intToRoman(self, num: int) -> str:
        # 定义一个字典存放对应的字符
        d = {0: 'IV',
             1: 'XL',
             2: 'CD',
             3: 'M'}
        # 这里的b表示个十百千的位数，后面会用到
        b = 0
        s = ''
        # b<3表示超过1000的部分就不适用下面的运算
        while num > 0 and b < 3:
            num, rem = divmod(num, 10)
            if rem < 4:
                sub_s = d[b][0] * rem
            elif rem == 4:
                sub_s = d[b]
            elif rem > 4 and rem < 9:
                sub_s = d[b][1] + d[b][0] * (rem - 5)
            else:
                sub_s = d[b][0] + d[b+1][0]
            s = sub_s + s
            # 每次b加1表示表示下一次处理更高一位，对应字典d中的键
            b += 1
        if num > 0:
            sub_s = num * d[3]
            return sub_s + s
        else:
            return s
```

运行速度很快（超过97%），但是这种想法拐了太多弯了，有点复杂，下面是一个别人的答案：
```python
class Solution:
    def intToRoman(self, num: int) -> str:
        s = ''
        rm = ((1000, 'M'), 
              (900, 'CM'),
              (500, 'D'), 
              (400, 'CD'), 
              (100, 'C'), 
              (90, 'XC'), 
              (50, 'L'), 
              (40, 'XL'), 
              (10, 'X'), 
              (9, 'IX'), 
              (5, 'V'), 
              (4, 'IV'), 
              (1, 'I'))
        # 对num从大到小进行除运算，再从num中减掉被运算过的部分
        for i, m in enumerate(rm):
            q, r = divmod(num, m[0])
            s += m[1] * q
            num -= q * m[0]
        return s
```

他是把所有可能出现的字符串类型都存在了一个元组中，再按照这些字符串对应的数值从大到小的顺序，每次都去掉包含最大数值的部分，
再把剩下的数跟小数值进行运算，一直算到`1`，这种方法速度上稍微慢了一点点（因为对每个num都要完整的遍历元组rm），但是非常简洁和直接

### 结论

- 对于整数的处理，有时候可以试试从`高位到低位`计算的顺序
- 字典还是香啊


## 13.Roman To Integer

[题目链接](https://leetcode.com/problems/roman-to-integer/)

这个题和[Integer To Roman](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/IntegerToRoman.md)类似，先用一个字典储存数值和字符的对应关系，再进行遍历即可：
```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I': 1,
             'V': 5,
             'IV': 4,
             'X': 10,
             'IX': 9,
             'L': 50,
             'XL': 40,
             'C': 100,
             'XC': 90,
             'D': 500,
             'CD': 400,
             'M': 1000,
             'CM': 900}
        res = i = 0
        while i < len(s):
            if s[i: i+2] in d:
                res += d[s[i: i+2]]
                i += 1
            else:
                res += d[s[i]]
            i += 1
        return res
```

一开始先把字符串给反转过来了，其实没必要，反正是加一个总和，一把成，没啥难点


## 14.Longest Common Prefix

[题目链接](https://leetcode.com/problems/longest-common-prefix/)

寻找字符串前缀，python中有一个很方便的函数`startswith()`，对每一个字符进行遍历即可：
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) < 1:
            return ''
        p = ''
        for i in range(len(strs[0])):
            all_pass = True
            p = strs[0][: i+1]
            print(p)
            for j in range(len(strs)):
                if not strs[j].startswith(p):
                    all_pass = False
                    break
            # all_pass 的值为 False说明没有全部通过，那么前缀就是上一个p，也就是p[: -1]
            if not all_pass:
                p = p[: -1]
                break
        return p
```

不过`startswith()`毕竟是python内置的方法，自己来写一个通用的方法可能更好一些，那就逐位去判断每个字符串的对应位置字符是否相等
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if len(strs) < 1:
            return ''
        num = 0
        for i in range(len(strs[0])):
            all_pass = True
            p = strs[0][i]
            print(p)
            # 判断每个字符串的第i位是否相等
            for j in range(len(strs)):
                try:
                    if strs[j][i] != p:
                        all_pass = False
                        break
                # 如果后面的字符串比第一个字符串长，则会产生一个超出索引范围的异常
                # 这也意味着当前的前缀字符strs[0][p]不是共同的前缀，置all_pass为False
                except:
                    all_pass = False
                    break
            if not all_pass:
                num = i
                break
            # 如果all_pass为True，说明当前的前缀字符strs[0][p]是共同的前缀，更新索引值，继续判断下一个字符
            num = i + 1
        return strs[0][: num]
```

自己重写的方法反而比startwith()更快了（超过99%）


## 15.Three Sum (Attention)

[题目链接](https://leetcode.com/problems/3sum/)

[Two Sum](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/TwoSum.md)的升级版，不光是数量升级，返回的结果也从只获取一个满足条件的数组变成了所有满足条件的数组，而且还不能重复

这道题还有一个解法是[Four Sum](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/FourSum.md)中的利用边界条件，很奇怪的是这种方法在Four Sum中很快，在这里却很慢，存疑？

首先自己想的是对每一个元素i，除去i后对剩下的列表做Two Sum的操作，target变成`-nums[i]`，对Two Sum稍加修改即可：
```python
class Solution:
    def __init__(self):
        self.res_list = []
    def twosum(self, sub_l, tar):
        d = []
        for j in sub_l:
            n = tar - j
            if j not in d:
                d.append(n)
            else:
                sub_list = [-tar, n, j]
                sub_list.sort()   # 根据排序来判断是否有重复
                if sub_list not in self.res_list:
                    self.res_list.append(sub_list)

    def threeSum(self, nums: List[int]) -> List[List[int]]:
        for i in range(len(nums) - 2):
            tar = -nums[i]
            self.twosum(nums[i+1:], tar)
        return self.res_list
```
超时了，之后怎么也没想出更快的方法（有点苗头但没去试）

看了别人的答案，基本思想都是将整个列表分成正负两部分，然后就是各自的奇思妙想，都要加上一堆判断，如：
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        first_number = set()
        answers = []
        if len(nums) < 3:
            return []
        # 排序，也相当于把正负值分开了
        nums.sort()
        # 如果全为正或全为负就不会出现和为0
        if nums[0] > 0 or nums[-1] < 0:
            return []
        
        for first in range(len(nums) - 2):
            # 对于相同的数字没必要多次判断
            if first > 0 and nums[first] == nums[first-1]:
                continue
            # 只遍历前面的负值
            if nums[first] > 0:
                return answers
            low = first + 1
            high = len(nums) - 1
            while low < high:
                target = nums[first] + nums[low] + nums[high]
                # 如果target>0，说明正值大了，就往前找一个
                if target > 0:
                    high -=  1
                # 如果target<0，说明负值小了，就往后找一个
                elif target < 0:
                    low += 1
                # 如果target=0，记录结果，并继续往中间找
                else:
                    answers.append([nums[first],nums[low], nums[high]])
                    low += 1
                    high -=  1
                    while low < high and nums[low] == nums[low-1]:
                        low += 1
                    while low < high and nums[high] == nums[high+1]:
                        high -= 1
        return answers
```

逻辑上面有些复杂

还有一种方法比较快：
```python
class Solution:
    def threeSum(self, nums):
        if not nums:
            return []

        res = []
        dic = {}
        # 记录每个数字的出现次数
        for n in nums:
            if n not in dic:
                dic[n] = 0
            dic[n] += 1

        if 0 in dic and dic[0] > 2:
            res.append([0,0,0])
        
        # 将正值和负值分开存放
        pos = []
        neg = []
        for n in dic:
            if n > 0:
                pos.append(n)
            elif n < 0:
                neg.append(n)

        for p in pos:
            for n in neg:
                target = -(p + n)
                if target in dic:
                    if target == p and dic[p] > 1:
                        res.append([p, p, n])
                    elif target == n and dic[n] > 1:
                        res.append([n, n, p])
                    # 只添加在[n, p]这个区间之内的target，避免重复
                    elif target < p and target > n:
                        res.append([n, p, target])
        return res
```

最后一种方法逻辑上更清晰一些，使用字典来存储，运行的速度也比较快


## 16.Three Sum Closest

[题目链接](https://leetcode.com/problems/3sum-closest/)

和[Three Sum](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/ThreeSum.md)类似，不过是要找一个三个数的和与目标最接近的数组，直接暴力解法最容易：
```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        t = float('inf')
        for i in range(len(nums) - 2):
            two_tar = target - nums[i]
            for j in range(i+1, len(nums)-1):
                tar_last = two_tar - nums[j]
                for k in nums[j+1:]:
                    dif = tar_last - k
                    # print([nums[i], nums[j], k], dif)
                    if dif == 0:
                        return target
                    if abs(dif) < abs(t):
                        t = dif
        return target - t
```
出乎意料的没有超时（超过了5%），这种方法没啥好说的，挨个遍历就完事了

比较快速的那些答案中，又是加上了一堆五花八门的判断条件，没有啥通用性可言

其实自己在思考更快速方法的时候，想到了排序再根据左右端点加一减一的这种方法，但是实际操作的时候不会写判断条件了，这次要记住，判断条件就是：
```python
while left < right:
    Dosomething
```

程序示例
```python
class Solution:
    def threeSumClosest(self, nums, target):
        n = len(nums)
        nums.sort()
        result = [float('inf'), None]  
		
        for k in range(n-2):
            a = nums[k]
            left_pointer = k + 1   # 从k+1开始查找，因为前面的都出现过了
            right_pointer = n - 1
            # 注意判断条件
            while left_pointer < right_pointer:
                b, c = nums[left_pointer], nums[right_pointer]
                diff = abs(target - (a + b + c))

                if diff == 0:
                    # if the abs value == 0 just return target which is our sum
                    return target
                if a + b + c < target:
				    # increment left pointer by 1 to get high value
                    left_pointer += 1
                else:
				    # decrement right pointer by 1 to get low value
                    right_pointer -= 1
                # if diff is less than our current result then we update it with new value
				# in the result field we need two fields: 1. to store diff 2. to store the sum
                if diff < result[0]:
                    result[0], result[1] = diff, a + b + c

        return result[1]
```

思想就是先把原来的列表排序，然后两头加，要是结果偏大了，就将左端点左移（相当于取一个更小的元素），要是结果偏小了，
就将右端点右移（相当于取一个更大的元素）

### 结论

- 牢记左右端点这种问题的判断方法：`while l < r`

### 知识点

- Python中获取一个无穷大值
  - 1.`m = sys.maxsize`
  - 2.`m = float('inf')`


## 17.Letter Combinations Of A Phone Number

[题目链接](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

自己做出来了，成绩不错，但是略复杂，看注释吧：
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if '0' in digits or '1' in digits or len(digits) < 1:
            return []
        # 数字与字符串的对应
        s_dict = {'2': 'abc',
                  '3': 'def',
                  '4': 'ghi',
                  '5': 'jkl',
                  '6': 'mno',
                  '7': 'pqrs',
                  '8': 'tuv',
                  '9': 'wxyz',
                 }
        # len_all是最终结果列表的长度，计算方法是每个数字对应的字符串的长度之积
        # last_len是上一个数字对应的字符串长度，因为在结果中，后面的字符串有多长就意味着前面的字符要重复几次
        # 例如给出的数字字符串为'23'，'3'对应的'def'长度为3，那么结果中'2'对应的字符串中每个字符要重复3次：['ad', 'ae', 'af', 'bd' ...]
        len_all = last_len = 1
        for i in range(len(digits)):
            len_all *= len(s_dict[digits[i]])
        for i in range(len(digits)):
            # 从后往前查询
            n = len(digits) - i - 1
            # 如果是最后一个数字，则初始化一个结果列表，最后面的数字对应的字符按顺序要重复（总长度 / 该数字对应字符个数）次
            if i == 0:
                res = list((s_dict[digits[n]] * int(len_all/len(s_dict[digits[n]]))))
            else:
                last_len *= len(s_dict[digits[n+1]])

                # 之后的数字对应的字符，首先要每个字符连续重复（该数字后面所有数字各自对应的字符个数之积）次
                # 然后再整体重复（总长度 / 该数字以及后面所有数字各自对应的字符个数之积）次
                # 例如，给出的数字为'567'，则'6'对应的每个字符要首先连续重复（'7'对应的长度）次：mmmmnnnnoooo
                # 然后再整体重复总长度（3*3*4）/('7'对应的长度（4）* 当前数字'6'对应字符数（3）)次，就是'mmmnnnnoooom'*3
                cur_list = ''.join([k*last_len for k in s_dict[digits[n]]] * int(len_all/(last_len*len(s_dict[digits[n]]))))
                # 最终结果就是每一次的列表对应位置相加
                res = [cur_list[j] + res[j] for j in range(len(res))]
        return res
```

这样实现速度也挺快，但是不是很容易理解，官方给出的答案使用了递归，似乎是一种更好的选择
```python
class Solution:
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        phone = {'2': ['a', 'b', 'c'],
                 '3': ['d', 'e', 'f'],
                 '4': ['g', 'h', 'i'],
                 '5': ['j', 'k', 'l'],
                 '6': ['m', 'n', 'o'],
                 '7': ['p', 'q', 'r', 's'],
                 '8': ['t', 'u', 'v'],
                 '9': ['w', 'x', 'y', 'z']}
                
        def backtrack(combination, next_digits):
            # if there is no more digits to check
            if len(next_digits) == 0:
                # the combination is done
                # 加完了就把结果添加到output中
                output.append(combination)
            # if there are still digits to check
            else:
                # iterate over all letters which map 
                # the next available digit
                # 对当前数字对应的每一个字符进行遍历
                for letter in phone[next_digits[0]]:
                    # append the current letter to the combination
                    # and proceed to the next digits
                    # combination是前面所有字符的拼接，再加上当前字符，然后对之后的数字做相同操作
                    backtrack(combination + letter, next_digits[1:])
                    
        output = []
        if digits:
            backtrack("", digits)
        return output
```

递归的方法实现起来代码非常简单，只是设计的时候判断条件什么的不太好想

### 结论

- 对于重复性操作的题目，想想递归，往往逻辑上比较简单，也比较高级


## 18.Four Sum

[题目链接](https://leetcode.com/problems/4sum/)

基本承袭了[Three Sum](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/ThreeSum.md)的套路，用类似的左右端点方法就能解决，只不过多遍历了一次（因为多了一个数）：

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        if len(nums) < 4:
            return []
        # 排序很重要
        nums.sort()
        res_list = []
        for i in range(len(nums) - 3):
            tar3 = target - nums[i]
            for j in range(i+1, len(nums)-2):
                tar2 = tar3 - nums[j]
                l = j + 1
                r = len(nums) - 1
                while l < r:
                    cur_l = nums[l]
                    cur_r = nums[r]
                    if cur_l + cur_r == tar2:
                        res = [nums[i], nums[j], cur_l, cur_r]
                        # 避免重复
                        if res not in res_list:
                            res_list.append(res)                      
                        l += 1
                        r -= 1
                    elif cur_l + cur_r > tar2:
                        r -= 1
                    else:
                        l += 1
        return res_list
```

当然这种近似暴力的解法速度不会很快（超过30%）

看了一个高分答案，思路清奇：
```python
class Solution:
    def fourSum(self, n: List[int], t:int) -> List[List[int]]:
        n.sort()
        if not n:
            return []
        length = len(n)
        posi = {j:i for i,j in enumerate(n)}
        # 用集合来储存结果，直接就可以避免重复
        # 不过注意集合里面不能放列表
        res = set()
        biggest = n[-1]
        
        for i in range(length-3):
            a = n[i]
            # 此时a是最小的，如果4倍的a都比目标t大的话，后面无论怎么加，结果都比t大，所以可以直接break
            if 4*a > t:
                break
            # a + 3*biggest是a和其他三个数能计算出的最大值，如果比t小的话，说明a不够大，要向后继续取
            if a + 3*biggest < t:
                continue
            for j in range(i+1,length-2):
                b = n[j]
                # 和上面一样的道理，如果最小值都比目标大，就没有计算的必要
                if a + 3*b > t:
                    break
                # 如果最大值比目标小，就向后取
                if a + b + 2*biggest < t:
                    continue
                for k in range(j+1,length-1):
                    c = n[k]
                    d = t - a - b - c
                    # d是目标与其他三个数的差值
                    # 如果d比最大的数还要大，说明c取小了，继续向后取
                    if d > biggest:
                        continue
                    # 如果d比当前最小的数c还要小，说明无论c怎么取，d都不会在列表中，直接break
                    if d < c:
                        break
                    if d in posi and posi[d] > k:
                        res.add((a,b,c,d))
        return res
```

他这个按边界条件来判断，能够省去很多的遍历，是个好思路

但有一个问题是，同样把这个边界条件的方法用到Three Sum中，就慢了很多，难道是因为Three Num的target始终为0？还是Three Num的测试比较多？

### 结论

- 1.排序之后根据边界条件来判断，如果不满足边界条件，那么之后的遍历都可以省略

- 2.使用set()集合来代替字典，能够避免出现重复的元素。但是要注意集合里面不能存放列表；而且似乎用集合会比列表加个判断`if element not in l`慢一些


## 19.Remove Nth Node From End Of List

[题目链接](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

单链表的题目（凸显出数据结构与算法这门课的重要性，还好选了它），删除指定的节点，有两种方法：

- 1.使用单个指针，计算链表长度
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# two pass, one pointer
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        length = 1
        d = {1: head}
        node = head
        while node.next:
            node = node.next
            length += 1
            d[length] = node
        if length == 1:
            return None
        # 如果n等于链表长度，头指针就要变化
        if n == length:
            head = d[2]
        else:
            d[length-n].next = d[length+1-n].next
        return head
```

- 2.使用两个指针，fir指针先走n个节点，然后和sec指针一起走，当fir走到头的时候，sec.next就是要删除的节点
```python
# one pass, two pointer
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # 为方便对特殊情况（比如单链表长度为1）的处理，在最前面加入一个新的头指针
        s_head = ListNode(0)
        s_head.next = head
        # fir和sec一开始都是新的头指针
        fir = sec = s_head
        # fir先走n个节点
        for i in range(n):
            fir = fir.next
        while fir.next:
            fir = fir.next
            sec = sec.next
        # sec.next是要删除的那个节点，如果它是头结点，那头结点就要变化
        if sec.next == head:
            head = head.next
        else:
            sec.next = sec.next.next
        return head
```

总体来说这道题比较简单，因为了解单链表的原理

用两个指针的方法很棒，自己没有想到

### 结论

- 在处理链表问题的时候，自行为其创建一个`新的头结点`，能把问题变得更普遍性


## 20.Valid Parentheses

From today on, the articles will be writed in English

[Problem Link](https://leetcode.com/problems/valid-parentheses/)

Find the valid parentheses.My thought is creating a dictionary, the keys are three left parentheses, and their value
is a list. Traverse the given string, add every index of left parenthese at the end of lists. When a right parenthese
appears, pop the last element of the corresponding left list, and check if the difference of the indexs of this pair 
of parentheses (to avoid the situation such as `[(]`). Finally, three lists in the dictionary should be empty, otherwise, 
return False.

```python
class Solution:
    def isValid(self, s: str) -> bool:
        d = {'(': [],
             '[': [],
             '{': [],}
        for index, val in enumerate(s):
            # the three if has the same structer
            if val == ')':
                # if there is no corresponding left parenthese, return False
                if len(d['(']) == 0:
                    return False
                else:
                    last_left = d['('].pop(-1)
                    # between a pair of parentheses, there must be even elements
                    if (index-last_left) % 2 == 0:
                        return False
            elif val == ']':
                if len(d['[']) == 0:
                    return False
                else:
                    last_left = d['['].pop(-1)
                    if (index-last_left) % 2 == 0:
                        return False
            elif val == '}':
                if len(d['{']) == 0:
                    return False
                else:
                    last_left = d['{'].pop(-1)
                    if (index-last_left) % 2 == 0:
                        return False
            else:
                d[val].append(index)
        # if finally the three lists are all empty, that means the given string is valid
        if d['('] == d['['] == d['{'] == []:
            return True
        else:
            return False
```

It'a gooo solution, and it's fast(beat 95%). But it has a complex coding.

Look at the offical solution, it use stack to store every character. When we meet a right parenthese, check the top of the stack, 
if it can pair with current right parenthese, pop the top and go on, otherwise, return False.

```python
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """

        # The stack to keep track of opening brackets.
        stack = []

        # Hash map for keeping track of mappings. This keeps the code very clean.
        # Also makes adding more types of parenthesis easier
        mapping = {")": "(", "}": "{", "]": "["}

        # For every bracket in the expression.
        for char in s:

            # If the character is an closing bracket
            if char in mapping:

                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'

                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)

        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack
```

### Conclution

- Stack is a magic thing.
