---
layout: article
tags: Leetcode Python
title: Leetcode problems 301-320
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 301 to 320, writing in Python.

<!--more-->

## 303. Range Sum Query - Immutable

[Problem link](https://leetcode.com/problems/range-sum-query-immutable/)

- My approach

My idea is brout force.

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.l = nums

    def sumRange(self, i: int, j: int) -> int:
        return sum(self.l[i:j+1])


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)
```

- Official solution

We can calculate the sum firstly and save them in an array. So we don't need to calculate in every call.

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.res = nums[:]
        for i in range(1, len(nums)):
            self.res[i] = nums[i] + self.res[i-1]
        self.res = [0] + self.res
        
    def sumRange(self, i: int, j: int) -> int:
        return self.res[j+1] - self.res[i]


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)
```


## 304. Range Sum Query 2D - Immutable

[Problem link](https://leetcode.com/problems/range-sum-query-2d-immutable/)

- My approach

We can save the sum as in `Range Sum Query` row by row. And when calculate the whole sum, add the rows together.

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.num = []
        # self.num[i][j+1] stands for the sum of matrix[i][:j+1]
        for r in matrix:
            curr = r[:]
            for i in range(1, len(r)):
                curr[i] = curr[i-1] + r[i]
            curr = [0] + curr
            self.num.append(curr)

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        res = 0
        for r in range(row1, row2+1):
            res += self.num[r][col2+1] - self.num[r][col1]
        return res


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
```

Or we can save the sum od squares. self.num[i+1][j+1] here stands for the sum of matrix[:i+1][:j+1]

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.num = []
        if not matrix:
            return
        for i in range(len(matrix)+1):
            self.num.append([0]*(len(matrix[0])+1))
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                self.num[i+1][j+1] = matrix[i][j] + self.num[i+1][j] + self.num[i][j+1] - self.num[i][j]
        

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.num[row2+1][col2+1] - self.num[row1][col2+1] - self.num[row2+1][col1] + self.num[row1][col1]


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
```

## 306. Additive Number

[Problem link](https://leetcode.com/problems/additive-number/)

- My approach

The key point of this problem is to find the correct beginning first and second addition number. Thecan be all the possible combinations from the start.

```python
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        # Check if the two addition numbers can add to the end
        def checkAdd(first, second, idx, start):
            if idx >= len(num) and not start:
                return True
            third = first + second
            if str(third) == num[idx:len(str(third))+idx] and num[idx] != 0:
                return checkAdd(second, third, len(str(third))+idx, False)
            else:
                return False

        for i in range(len(num)):
            first = int(num[:i+1])
            for j in range(i+1, len(num)):
                # A '0' can only be a single digit number 0 as second addition, but can't be at the start of other numbers
                if num[i+1] == '0' and j > i+1:
                    break
                second = int(num[i+1:j+1])
                if checkAdd(first, second, j+1, True):
                    return True
            # If the first number of num is 0, only 0 can be the first addition
            if num[0] == '0':
                break
        return False
```


## 307. Range Sum Query - Mutable  (Official approach)

[Problem link](https://leetcode.com/problems/range-sum-query-mutable/)

- My approach

My idea is us the method of []() to save the sums, and save the updated positions in an dictionary. When calculate the whole sum, reduce the numbers in the dictionary.

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.sum = nums[:]
        for i in range(1, len(nums)):
            self.sum[i] = self.sum[i] + self.sum[i-1]
        self.sum = [0] + self.sum
        self.diff = {}

    def update(self, i: int, val: int) -> None:
        self.diff[i] = val

    def sumRange(self, i: int, j: int) -> int:
        diff = 0
        for k in self.diff:
            # print(k)
            if i <= k <= j:
                diff += self.sum[k+1] - self.sum[k] - self.diff[k]
                # print(self.sum[k+1], self.sum[k], self.diff[k])
        return self.sum[j+1] - self.sum[i] - diff
        


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(i,val)
# param_2 = obj.sumRange(i,j)
```

- Official approach

There is a more smarter method by dividing the nums to `sqrt(n)` parts.

```python
class NumArray:
    def __init__(self, nums):
        self.N = len(nums)
        self.size = int(self.N ** 0.5) + 1
        self.A = [0] * self.N
        self.bucket = [0] * self.size  # bucket[i] stands for the sum of [i:i+sqrt(N)]
        for i, val in enumerate(nums):
            self.update(i, val)
            
    def update(self, i, val):
        bidx = i // self.size
        self.bucket[bidx] += val - self.A[i]
        self.A[i] = val
        print(self.bucket, self.A)
        
    def sumRange(self, i, j):
        idx, jdx = i//self.size, j//self.size
        # print(self.bucket)
        total = sum(self.bucket[idx:jdx+1])
        total -= sum(self.A[idx*self.size:i])
        total -= sum(self.A[j+1:(jdx+1)*self.size])
        return total
```

