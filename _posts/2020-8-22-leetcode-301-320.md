---
layout: article
tags: Leetcode Python
title: Leetcode problems 301-320
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 301 to 320, writing in Python.

<!--more-->

## 303. Range Sum Query - Immutable

[Problem link](https://leetcode.com/problems/range-sum-query-immutable/)

- My approach

My idea is brout force.

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.l = nums

    def sumRange(self, i: int, j: int) -> int:
        return sum(self.l[i:j+1])


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)
```

- Official solution

We can calculate the sum firstly and save them in an array. So we don't need to calculate in every call.

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.res = nums[:]
        for i in range(1, len(nums)):
            self.res[i] = nums[i] + self.res[i-1]
        self.res = [0] + self.res
        
    def sumRange(self, i: int, j: int) -> int:
        return self.res[j+1] - self.res[i]


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)
```


## 304. Range Sum Query 2D - Immutable

[Problem link](https://leetcode.com/problems/range-sum-query-2d-immutable/)

- My approach

We can save the sum as in `Range Sum Query` row by row. And when calculate the whole sum, add the rows together.

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.num = []
        # self.num[i][j+1] stands for the sum of matrix[i][:j+1]
        for r in matrix:
            curr = r[:]
            for i in range(1, len(r)):
                curr[i] = curr[i-1] + r[i]
            curr = [0] + curr
            self.num.append(curr)

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        res = 0
        for r in range(row1, row2+1):
            res += self.num[r][col2+1] - self.num[r][col1]
        return res


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
```

Or we can save the sum od squares. self.num[i+1][j+1] here stands for the sum of matrix[:i+1][:j+1]

```python
class NumMatrix:

    def __init__(self, matrix: List[List[int]]):
        self.num = []
        if not matrix:
            return
        for i in range(len(matrix)+1):
            self.num.append([0]*(len(matrix[0])+1))
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                self.num[i+1][j+1] = matrix[i][j] + self.num[i+1][j] + self.num[i][j+1] - self.num[i][j]
        

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:
        return self.num[row2+1][col2+1] - self.num[row1][col2+1] - self.num[row2+1][col1] + self.num[row1][col1]


# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)
```

## 306. Additive Number

[Problem link](https://leetcode.com/problems/additive-number/)

- My approach

The key point of this problem is to find the correct beginning first and second addition number. Thecan be all the possible combinations from the start.

```python
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        # Check if the two addition numbers can add to the end
        def checkAdd(first, second, idx, start):
            if idx >= len(num) and not start:
                return True
            third = first + second
            if str(third) == num[idx:len(str(third))+idx] and num[idx] != 0:
                return checkAdd(second, third, len(str(third))+idx, False)
            else:
                return False

        for i in range(len(num)):
            first = int(num[:i+1])
            for j in range(i+1, len(num)):
                # A '0' can only be a single digit number 0 as second addition, but can't be at the start of other numbers
                if num[i+1] == '0' and j > i+1:
                    break
                second = int(num[i+1:j+1])
                if checkAdd(first, second, j+1, True):
                    return True
            # If the first number of num is 0, only 0 can be the first addition
            if num[0] == '0':
                break
        return False
```


## 307. Range Sum Query - Mutable  (Official approach)

[Problem link](https://leetcode.com/problems/range-sum-query-mutable/)

- My approach

My idea is us the method of []() to save the sums, and save the updated positions in an dictionary. When calculate the whole sum, reduce the numbers in the dictionary.

```python
class NumArray:

    def __init__(self, nums: List[int]):
        self.sum = nums[:]
        for i in range(1, len(nums)):
            self.sum[i] = self.sum[i] + self.sum[i-1]
        self.sum = [0] + self.sum
        self.diff = {}

    def update(self, i: int, val: int) -> None:
        self.diff[i] = val

    def sumRange(self, i: int, j: int) -> int:
        diff = 0
        for k in self.diff:
            # print(k)
            if i <= k <= j:
                diff += self.sum[k+1] - self.sum[k] - self.diff[k]
                # print(self.sum[k+1], self.sum[k], self.diff[k])
        return self.sum[j+1] - self.sum[i] - diff
        


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(i,val)
# param_2 = obj.sumRange(i,j)
```

- Official approach

There is a more smarter method by dividing the nums to `sqrt(n)` parts.

```python
class NumArray:
    def __init__(self, nums):
        self.N = len(nums)
        self.size = int(self.N ** 0.5) + 1
        self.A = [0] * self.N
        self.bucket = [0] * self.size  # bucket[i] stands for the sum of [i:i+sqrt(N)]
        for i, val in enumerate(nums):
            self.update(i, val)
            
    def update(self, i, val):
        bidx = i // self.size
        self.bucket[bidx] += val - self.A[i]
        self.A[i] = val
        print(self.bucket, self.A)
        
    def sumRange(self, i, j):
        idx, jdx = i//self.size, j//self.size
        # print(self.bucket)
        total = sum(self.bucket[idx:jdx+1])
        total -= sum(self.A[idx*self.size:i])
        total -= sum(self.A[j+1:(jdx+1)*self.size])
        return total
```

## 309. Best Time to Buy and Sell Stock with Cooldown  (Dynamic program)

[Problem link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

- My approach

My idea is using recursing method to enumerate all the possible situations, but it was time limited exceeded.

- Other's approach

There is a dynamic program from others.

The key point of dynamic program is finding the relationship of current element with the elements before.

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
		# initialization
        cool_down, sell, hold = 0, 0, -float('inf')
        
        for stock_price_of_Day_i in prices:
            
            prev_cool_down, prev_sell, prev_hold = cool_down, sell, hold
            
            # Max profit of cooldown on Day i comes from either cool down of Day_i-1, or sell out of Day_i-1 and today Day_i is cooling day
            cool_down = max(prev_cool_down, prev_sell)
            
            # Max profit of sell on Day_i comes from hold of Day_i-1 and sell on Day_i
            sell = prev_hold + stock_price_of_Day_i
            
            # Max profit of hold on Day_i comes from either hold of Day_i-1, or cool down on Day_i-1 and buy on Day_i
            hold = max(prev_hold, prev_cool_down - stock_price_of_Day_i)
        
        
        # The action of final trading day must be either sell or cool down
        return max(sell, cool_down)
```


## 310. Minimum Height Trees

[Problem link](https://leetcode.com/problems/minimum-height-trees/)

- My approach

My idea is using recursing to find the height of all the possible tree, and return the minimum, but it was time limited exceeded.

- Other's approach

We can notice that the root of trees with minimum height must in the middle. Or we can see in the graph, it must have more than one connections. So we can start from the leaves, 
every time cut on leaf until there are all leaf nodes, the remained nodes are the root of minimum trees.

```python
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        connections = defaultdict(set)
        for x, y in edges:
            connections[x].add(y)
            connections[y].add(x)
            
        leaves = [x for x in range(n) if len(connections[x]) == 1]
        while leaves and len(leaves) < len(connections):
            new = []
            for x in leaves:
                for y in connections[x]:
                    connections[y].remove(x)  # cut leaves
                    if len(connections[y]) == 1:  # current node may become a new leaf
                        new.append(y)
                connections.pop(x)  # remove leaf nodes
            leaves = new
        return list(connections)
```
