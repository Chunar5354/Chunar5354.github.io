---
layout: article
tags: Leetcode Python
title: Leetcode problems 461-480
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 461 to 480, writing in Python.

<!--more-->

## 461. Hamming Distance

[Problem link](https://leetcode.com/problems/hamming-distance/)

- My approach

Count bit by bit.

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        while x > 0 and y > 0:
            xi = x % 2
            yi = y % 2
            x = x // 2
            y = y // 2
            if xi != yi:
                res += 1

        while x > 0:
            xi = x % 2
            x = x // 2
            if xi != 0:
                res += 1
        while y > 0:
            yi = y % 2
            y = y // 2
            if yi != 0:
                res += 1
        return res
```

- Other's approach

Firstly calculate `n=(x^y)`(XOR), the counte of bit 1 in n is the different bits of x and y.

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x ^ y).count('1')
```


## 462. Minimum Moves to Equal Array Elements II

[Problem link](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)

- My approach

The final number of the minimum move is the median number of nums. So the result is the sum of distances to median number.

```python
class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        nums.sort()
        l = len(nums)
        m = l // 2
        if l % 2 == 0:
            median = (nums[m]+nums[m-1]) // 2
        else:
            median = nums[m]
        res = 0
        for n in nums:
            res += abs(n-median)
        return res
```

