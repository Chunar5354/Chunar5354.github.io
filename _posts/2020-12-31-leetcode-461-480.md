---
layout: article
tags: Leetcode Python
title: Leetcode problems 461-480
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 461 to 480, writing in Python.

<!--more-->

## 461. Hamming Distance

[Problem link](https://leetcode.com/problems/hamming-distance/)

- My approach

Count bit by bit.

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        while x > 0 and y > 0:
            xi = x % 2
            yi = y % 2
            x = x // 2
            y = y // 2
            if xi != yi:
                res += 1

        while x > 0:
            xi = x % 2
            x = x // 2
            if xi != 0:
                res += 1
        while y > 0:
            yi = y % 2
            y = y // 2
            if yi != 0:
                res += 1
        return res
```

- Other's approach

Firstly calculate `n=(x^y)`(XOR), the counte of bit 1 in n is the different bits of x and y.

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x ^ y).count('1')
```


## 462. Minimum Moves to Equal Array Elements II

[Problem link](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)

- My approach

The final number of the minimum move is the median number of nums. So the result is the sum of distances to median number.

```python
class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        nums.sort()
        l = len(nums)
        m = l // 2
        if l % 2 == 0:
            median = (nums[m]+nums[m-1]) // 2
        else:
            median = nums[m]
        res = 0
        for n in nums:
            res += abs(n-median)
        return res
```


## 463. Island Perimeter

[Problem link](https://leetcode.com/problems/island-perimeter/)

- My approach

Every cell has 4 perimeters, but if one cell is connected with another cell, the count of perimeters will be reduced by 2.

```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if (i-1 >= 0 and grid[i-1][j] == 1) and (j-1 >= 0 and grid[i][j-1] == 1):
                        continue
                    if i-1 >= 0 and grid[i-1][j] == 1:
                        count += 2
                    elif j-1 >= 0 and grid[i][j-1] == 1:
                        count += 2
                    else:
                        count += 4
        return count
```


## 464. Can I Win

[Problem link](https://leetcode.com/problems/can-i-win/)

- Other approach

There is no simple ways, just enumerate all the possible conditions.

For a current number set basket, current player can win means the max number can exceed desiredTotal, or in the next round, the other player can't win.

Click [here](https://leetcode.com/problems/can-i-win/discuss/526008/dfs-%2B-memoization-%3A-easy-to-understand-with-explanation) to see more explanation.

```python
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        basket = tuple(i+1 for i in range(maxChoosableInteger))
        
        if sum(basket) < desiredTotal:
            return False
        
        dic = {}  # set a memory to avoid duplications
        
        def dfs(basket,target):
            if basket[-1] >= target:  # current number is exceeded
                return True

            if basket in dic:
                return dic[basket]
            for i,num in enumerate(basket):
                if not dfs(basket[:i]+basket[i+1:],target-num):  # in the next round, the other player can't win
                    dic[basket] = True
                    return True
            dic[basket] = False
            return False
        return dfs(basket,desiredTotal)
```

