---
layout: article
tags: Leetcode Python
title: Leetcode problems 461-480
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 461 to 480, writing in Python.

<!--more-->

## 461. Hamming Distance

[Problem link](https://leetcode.com/problems/hamming-distance/)

- My approach

Count bit by bit.

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        while x > 0 and y > 0:
            xi = x % 2
            yi = y % 2
            x = x // 2
            y = y // 2
            if xi != yi:
                res += 1

        while x > 0:
            xi = x % 2
            x = x // 2
            if xi != 0:
                res += 1
        while y > 0:
            yi = y % 2
            y = y // 2
            if yi != 0:
                res += 1
        return res
```

- Other's approach

Firstly calculate `n=(x^y)`(XOR), the counte of bit 1 in n is the different bits of x and y.

```python
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x ^ y).count('1')
```


## 462. Minimum Moves to Equal Array Elements II

[Problem link](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)

- My approach

The final number of the minimum move is the median number of nums. So the result is the sum of distances to median number.

```python
class Solution:
    def minMoves2(self, nums: List[int]) -> int:
        nums.sort()
        l = len(nums)
        m = l // 2
        if l % 2 == 0:
            median = (nums[m]+nums[m-1]) // 2
        else:
            median = nums[m]
        res = 0
        for n in nums:
            res += abs(n-median)
        return res
```


## 463. Island Perimeter

[Problem link](https://leetcode.com/problems/island-perimeter/)

- My approach

Every cell has 4 perimeters, but if one cell is connected with another cell, the count of perimeters will be reduced by 2.

```python
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        count = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    if (i-1 >= 0 and grid[i-1][j] == 1) and (j-1 >= 0 and grid[i][j-1] == 1):
                        continue
                    if i-1 >= 0 and grid[i-1][j] == 1:
                        count += 2
                    elif j-1 >= 0 and grid[i][j-1] == 1:
                        count += 2
                    else:
                        count += 4
        return count
```


## 464. Can I Win

[Problem link](https://leetcode.com/problems/can-i-win/)

- Other approach

There is no simple ways, just enumerate all the possible conditions.

For a current number set basket, current player can win means the max number can exceed desiredTotal, or in the next round, the other player can't win.

Click [here](https://leetcode.com/problems/can-i-win/discuss/526008/dfs-%2B-memoization-%3A-easy-to-understand-with-explanation) to see more explanation.

```python
class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        basket = tuple(i+1 for i in range(maxChoosableInteger))
        
        if sum(basket) < desiredTotal:
            return False
        
        dic = {}  # set a memory to avoid duplications
        
        def dfs(basket,target):
            if basket[-1] >= target:  # current number is exceeded
                return True

            if basket in dic:
                return dic[basket]
            for i,num in enumerate(basket):
                if not dfs(basket[:i]+basket[i+1:],target-num):  # in the next round, the other player can't win
                    dic[basket] = True
                    return True
            dic[basket] = False
            return False
        return dfs(basket,desiredTotal)
```


## 466. Count The Repetitions  (Other's approach)

[Problem link](https://leetcode.com/problems/count-the-repetitions/)

- Other's approach

The key point is to find `cycle`. When find a repeated pattern that contains s1, check how many s1 is in this pattern. So we can find how many s2 can be contained in the whole 
s1*n1.

```python
class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:
        # hashtable to store the patterns
        patterns = {}

        # pointers on s1 and s2
        p1, p2 = 0, 0

        # number of occurance of s1 and s2 so far
        c1, c2 = 1, 0

        # execute the loop when number of occurance of s1 has not been used up
        while c1 <= n1:
            print(c1, c2)

            # if a character match is found, move p2 forward
            if s1[p1] == s2[p2]:
                p2 += 1

                # p2 reaches the end of s2, meaning 1 occurance of s2
            if p2 == len(s2):
                c2 += 1
                p2 = 0

                # store the pattern if not exists
                if p1 not in patterns:
                    patterns[p1] = (c1, c2)

                # a repeat has been found, handle the repeat
                else:
                    # previous occurance of s1 and s2
                    prev_c1, prev_c2 = patterns[p1]

                    # number of occurance of s1 and s2 in a single repeat
                    n_s1_repeat, n_s2_repeat = c1 - prev_c1, c2 - prev_c2

                    # number of repeats
                    n_repeats = (n1 - prev_c1) // n_s1_repeat
                    print(n_s1_repeat, n_s2_repeat, n_repeats)

                    # number of s2 occurances in the repeats
                    c2_repeats = n_repeats * n_s2_repeat

                    # the remain available occurances of s1
                    remain_c1 = (n1 - prev_c1) % n_s1_repeat

                    # update c1 and c2
                    c1 = n1 - remain_c1
                    c2 = c2_repeats + prev_c2

            # move forward p1 every iteration
            p1 += 1

            # p1 reaches the end of s1, move it back to 0 and mark 1 occurance of s1
            if p1 == len(s1):
                c1 += 1
                p1 = 0
    
        print(patterns)
        # divide c2 by n2 to get the result
        return c2 // n2
```


## 467. Unique Substrings in Wraparound String  (Other's approach)

[Problem link](https://leetcode.com/problems/unique-substrings-in-wraparound-string/)

- Other's approach

Since all the substrings are constructed by adjacent characters, we can ignore the specific strings, just find the max length of substrings start with every character.

For example, is p is 'abcdabc', the length pattern will be `4321321`, and the final structer will be {'a':4, 'b':3, 'c':2, 'd':1}, because 'abc' is contained in 'abcd', this 
method can avoid the duplications.

```python
class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        dic = {c:1 for c in p}
        l = 1
        for i in range(len(p)-2, -1, -1):  # sea4ch from right to left
            if (ord(p[i+1])-ord(p[i])) % 26 == 1:
                l += 1
                dic[p[i]] = max(dic[p[i]], l)
            else:
                l = 1
        return sum(dic.values())
```

