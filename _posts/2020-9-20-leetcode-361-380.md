---
layout: article
tags: Leetcode Python
title: Leetcode problems 361-380
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 361 to 380, writing in Python.

<!--more-->

## 363. Max Sum of Rectangle No Larger Than K  (Other's approach)

[Problem link](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/)

- My approach

My idea is saving the areas firstly, dp[i][j] stands for the area of square from dp[0][0] to dp[i][j]. Based on dp, we can search all the squares in the matrix.

```python
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        m = len(matrix)
        n = len(matrix[0])
        
        dp = []
        for _ in range(m+1):
            dp.append([0]*(n+1))
        
        dp[1][1] = matrix[0][0]
            
        for i in range(1, m+1):
            for j in range(1, n+1):
                dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]
        
        res = float('-inf')
        for r in range(m+1):
            for c in range(n+1):
                for i in range(r+1, m+1):
                    for j in range(c+1, n+1):
                        # area from dp[r][c] to dp[i][j]
                        curr = dp[i][j] - dp[i][c] - dp[r][j] + dp[r][c]
                        if curr > k:
                            continue
                        elif curr == k:
                            return k
                        else:
                            res = max(curr, res)
        
        return res
```

This apporoach has O(m*m*n*n) time complex, and it was time limit exceeded.

- Other's approach

The approach above can be improved.

```python
class Solution:
    def maxSumSubmatrix(self, w: List[List[int]], K: int) -> int:
        
        def get(x1: int, y1: int, x2: int, y2: int) -> int:
            return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
        
        n, m = len(w), len(w[0])

        s = [[0 for i in range(m + 1)] for y in range(n + 1)]
        for i in range (1, n + 1):
            for j in range (1, m + 1):
                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1]
        
        res = -sys.maxsize
        for i in range(1, m + 1):
            for j in range(i, m + 1):
                L = [0]
                for k in range(1, n + 1):
                    si = get(1, i, k, j)
                    it = bisect.bisect_left(L, si - K)
                    if it != len(L):
                        res = max(res, si - L[it])
                    bisect.insort(L, si)
        return res
```


## 365. Water and Jug Problem  (GCD)

[Problem link](https://leetcode.com/problems/water-and-jug-problem/)

- Other's approach

The key point is: if z is the multiple of the `gcd`(Greatest common divisor 最大公约数) of x and y, it must be measurable.

```python
class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        if not z: 
            return True #edge case 
        
        def gcd(x, y): 
            """Return greatest common divisor via Euclidean algo"""
            if x < y:
                x, y = y, x
            while y:
                x, y = y, x%y
            return x
        
        return z <= x + y and z % gcd(x, y) == 0
```


## 367. Valid Perfect Square

[Problem link](https://leetcode.com/problems/valid-perfect-square/)

- My approach

Use binary search, the max num is 2**31-1, ant the int(sqrt(2**31-1)) is 46340. So we start from 46340/2 to do binary search.

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l = 0
        r = 46341
        
        m = (l+r) // 2
        last = m
        
        while True:
            if m * m == num:
                return True
            elif m * m < num:
                l = m
                m = (m+r) // 2
            else:
                r = m
                m = (l+m) // 2
            if last == m:
                return False
            last = m
```

Or we can start search at num//2.

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left=0
        right=num
        while left<=right:
            mid=(left+right)//2
            square=mid*mid
            if square == num:
                return True
            elif square>num:
                right=mid-1
            else:
                left=mid+1
        return False
```


## 368. Largest Divisible Subset

[Problem link](https://leetcode.com/problems/largest-divisible-subset/)

- My approach

Use dynamic programming, dp[i] stands for the largest divisible subset until nums[i].

```python
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        nums.sort()
        dp = [[]] * len(nums)
        dp[0] = [nums[0]]
        
        for i in range(1, len(nums)):
            curr = [nums[i]]
            # Traverse nums[:i], is current nums[i] is divisible with dp[i][-1], it is divisible with all dp[i]
            for j in range(i):
                if nums[i] % dp[j][-1] == 0:
                    temp = dp[j] + [nums[i]]
                    if len(temp) > len(curr):
                        curr = temp
            dp[i] = curr

        res = []
        for l in dp:
            if len(l) > len(res):
                res = l
        return res
```

- Other's approach

We can find all the factors of n firstly. For every n, the largest divisible subset equals to the largest divisible subset of its factors plus current n.

```python
class Solution:
    def largestDivisibleSubset(self, nums):
        if not nums: return []
        
        nums.sort()
        def find_factors(n):
            factors = []
            for i in range(1, int(n**0.5)+1):
                if n % i == 0:
                    factors.append(i)
                    factors.append(n // i)
            return factors
            
        cache = dict()
        for n in nums:
            factors, subset = find_factors(n), []
            for f in factors:
                if f in cache:
                    if len(cache[f]) > len(subset):
                        subset = cache[f]
            cache[n] = subset + [n]
        return max(cache.values(), key=len)
```


## 371. Sum of Two Integers  (Other's approach)

[Problem link](https://leetcode.com/problems/sum-of-two-integers/)

- Other's approach

Use binary operation. From [this solution](https://leetcode.com/problems/sum-of-two-integers/discuss/699379/Python-Simple-bit-operations-solution-with-detailed-explanation)

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        ## RC ##
        ## APPROACH : BITWISE OPERATIONS ##
        ## LOGIC ##
        #   1. For any two numbers, if their binary representations are completely opposite, then XOR operation will directly produce sum of numbers ( in this case carry is 0 )
        #   2. what if the numbers binary representation is not completely opposite, XOR will only have part of the sum and remaining will be carry, which can be produced by and operation followed by left shift operation.
        #   3. For Example 18, 13 => 10010, 01101 => XOR => 11101 => 31 (ans found), and operation => carry => 0
        #   4. For Example 7, 5
        #   1 1 1                   1 1 1
        #   1 0 1                   1 0 1
        #   -----                   -----
        #   0 1 0   => XOR => 2     1 0 1  => carry => after left shift => 1 0 1 0
        #   2                                                              10
        # now we have to find sum of 2, 10 i.e a is replace with XOR result and b is replaced wth carry result
        # similarly repeating this process till carry is 0
        #   steps will be 7|5 => 2|10 => 8|4  => 12|0
        
		## TIME COMPLEXITY : O(1) ##
		## SPACE COMPLEXITY : O(1) ##
        
        # 32 bit mask in hexadecimal
        mask = 0xffffffff # (python default int size is not 32bit, it is very large number, so to prevent overflow and stop running into infinite loop, we use 32bit mask to limit int size to 32bit )
        while(b & mask > 0):
            carry = (a & b) << 1
            a = a ^ b
            b = carry
        return (a & mask) if b > 0 else a
```


## 372. Super Pow  (Recursing method)

[Problem link](https://leetcode.com/problems/super-pow/)

- Other's approach

Use recursing method, every time calculate a^b[-1].

```python
class Solution(object):
    def superPow(self, a, b):
        if len(b) == 1:
            return a ** b[0] % 1337
        return self.superPow(a, b[:-1]) ** 10 * a ** b[-1] % 1337
```

I was confused firstly that the number can only smaller than 2^64.


## 373. Find K Pairs with Smallest Sums  (Heap)

[Problem link](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

- My approach

Save all the pairs in to a list then sort them by their sum.

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        
        res = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                res.append([nums1[i], nums2[j]])
        
        res.sort(key=sum)
        
        return res[:k]
```

- Other's approach

Use heap to sort them while adding pairs. The elements to sort is smaller than k, so this method can run faster.

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if nums1 == [] or nums2 == []:
            return []
        
        heap = []
        for j in range(len(nums2)):
            heapq.heappush(heap, (nums1[0]+nums2[j], (0, j)))

        result = []
        while len(result) < k and len(heap) > 0:
            # Every time append one line and only pop one pair
            curr = heapq.heappop(heap)
            result.append([nums1[curr[1][0]], nums2[curr[1][1]]])
            if curr[1][0]+1 < len(nums1):
                i = curr[1][0]+1
                j = curr[1][1]
                heapq.heappush(heap, (nums1[i]+nums2[j], (i, j)))
        
        return result
```


## 374. Guess Number Higher or Lower

[Problem link](https://leetcode.com/problems/guess-number-higher-or-lower/)

- My approach

Use binary search.

```python
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -> int:

class Solution:
    def guessNumber(self, n: int) -> int:
        l = 0
        num = (l+n) // 2
        while guess(num) != 0:
            if guess(l) == 0:
                return l
            if guess(n) == 0:
                return n
            if guess(num) == 1:
                l = num
            elif guess(num) == -1:
                n = num
            num = (l+n) // 2
        return num
```


## 375. Guess Number Higher or Lower II  (Recursing)

[Problem link](https://leetcode.com/problems/guess-number-higher-or-lower-ii/)

- Other's approach

Use 2D cache and search by recursing. 

For every number, the cost will be the cost of guessing the numbers smaller current plus guessing the numbers larger than current plus current number(cost).

```python
class Solution:
    def getMoneyAmount(self, n):
        cache = [[0]*(n+1) for _ in range(n)]
        def guess(lo, hi):
            if lo >= hi:  # lo==hi means find the target, this will cost 0
                return 0
            if cache[lo][hi] > 0:
                return cache[lo][hi]
            ret = float('inf')
            for i in range((lo+hi)//2, hi):
                t= i + max(guess(lo, i-1),guess(i+1, hi))  # smaller numbers + larger numbers + current number
                ret = min(ret, t)
                
            cache[lo][hi] = ret
            return ret
        res = guess(1, n)
        return res
```


## 376. Wiggle Subsequence  (Other's approach)

[Problem link](https://leetcode.com/problems/wiggle-subsequence/)

- My approach

Dynamic programming with O(n^2) time complexity.

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        i = 1
        # delete adjacent numbers
        while i < len(nums):
            if nums[i] == nums[i-1]:
                nums.pop(i)
            else:
                i += 1
        if len(nums) <= 1:
            return len(nums)
            
        diff = [0] * (len(nums)-1)
        for i in range(len(nums)-1):
            if nums[i+1]-nums[i] > 0:
                diff[i] = 1
            elif nums[i+1]-nums[i] < 0:
                diff[i] = -1
        
        length = [1] * len(diff)
        for i in range(1, len(diff)):
            for j in range(i):
                if diff[i]*diff[j] == -1:
                    length[i] = max(length[i], length[j]+1)
                    
        return max(length) + 1
```

- Other's approach

Use two variables to store the up sequence and down sequence.

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if not nums:
            return 0
        up = down = 1
        for i in range(1, len(nums)):
            if nums[i] - nums[i-1] > 0:
                up = down + 1
            elif nums[i] - nums[i-1] < 0:
                down = up + 1
        return max(up, down)
```


## 377. Combination Sum IV  (Dynamic programming)

[Problem link](https://leetcode.com/problems/combination-sum-iv/)

- Other's approach

Dynamic programming. dp[i] stands for the combinations of sum to i.

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0] * (target+1) 
        for i in range(1, target+1):            # offset from 1 to skip base case (first element)
            for n in nums:
                if( n == i):                    # If number is in the list, you can directly count it as one combination
                    dp[i] += 1
                if n < i:                       
                    dp[i] += dp[i-n]        # include all the combinations of target i-n.
        return dp[-1]
```


## 378. Kth Smallest Element in a Sorted Matrix  (Other's approach)

[Problem link](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)

- Other's approach

The key point is how to find how many numbers smaller than target number in a 2D array.

```python
class Solution:
    def kthSmallest(self, matrix, k):
        n = len(matrix)
        lo, hi = matrix[0][0], matrix[-1][-1]
        
        while lo < hi:
            print(lo, hi)
            mid = (lo+hi) // 2
			
			      # saddleback search
            p, q, c = n-1, 0, 0 #(p,q) moving point, c: count
            while 0 <= p and q < n:
                if matrix[p][q] > mid:
                    p -= 1
                else:
                    c += p + 1 # how many numbers not larger than mid in qth column
                    q += 1
                    
            # binary search
            if c < k:
                lo = mid + 1
            else:
                hi = mid
            
        return lo
```


## 380. Insert Delete GetRandom O(1)

[Problem link](https://leetcode.com/problems/insert-delete-getrandom-o1/)

- My approach

Use one dictionary and one list to store the elements. When an element is inserted, just add it at the end of list, then store it as {value: index-of-list} in dictionary.
And when delete an element, firstly get its index from dictionary, then modify the position of list[idx] to list[-1], nextly pop the last element in list and modify dictionary, then 
delete the given val.

```python
class RandomizedSet:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}
        self.l = []
        

    def insert(self, val: int) -> bool:
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        """
        if val in self.d:
            return False
        else:
            self.l.append(val)
            self.d[val] = len(self.l)-1
            return True
        

    def remove(self, val: int) -> bool:
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        """
        if val not in self.d:
            return False
        else:
            idx = self.d[val]
            self.l[idx] = self.l[-1]
            self.d[self.l.pop()] = idx
            self.d.pop(val)
            return True

    def getRandom(self) -> int:
        """
        Get a random element from the set.
        """
        idx = random.choice(self.l)
    
# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```
