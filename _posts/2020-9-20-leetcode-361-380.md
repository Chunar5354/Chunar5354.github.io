---
layout: article
tags: Leetcode Python
title: Leetcode problems 361-380
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 361 to 380, writing in Python.

<!--more-->

## 363. Max Sum of Rectangle No Larger Than K  (Other's approach)

[Problem link](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/)

- My approach

My idea is saving the areas firstly, dp[i][j] stands for the area of square from dp[0][0] to dp[i][j]. Based on dp, we can search all the squares in the matrix.

```python
class Solution:
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        m = len(matrix)
        n = len(matrix[0])
        
        dp = []
        for _ in range(m+1):
            dp.append([0]*(n+1))
        
        dp[1][1] = matrix[0][0]
            
        for i in range(1, m+1):
            for j in range(1, n+1):
                dp[i][j] = matrix[i-1][j-1] + dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1]
        
        res = float('-inf')
        for r in range(m+1):
            for c in range(n+1):
                for i in range(r+1, m+1):
                    for j in range(c+1, n+1):
                        # area from dp[r][c] to dp[i][j]
                        curr = dp[i][j] - dp[i][c] - dp[r][j] + dp[r][c]
                        if curr > k:
                            continue
                        elif curr == k:
                            return k
                        else:
                            res = max(curr, res)
        
        return res
```

This apporoach has O(m*m*n*n) time complex, and it was time limit exceeded.

- Other's approach

The approach above can be improved.

```python
class Solution:
    def maxSumSubmatrix(self, w: List[List[int]], K: int) -> int:
        
        def get(x1: int, y1: int, x2: int, y2: int) -> int:
            return s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]
        
        n, m = len(w), len(w[0])

        s = [[0 for i in range(m + 1)] for y in range(n + 1)]
        for i in range (1, n + 1):
            for j in range (1, m + 1):
                s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + w[i - 1][j - 1]
        
        res = -sys.maxsize
        for i in range(1, m + 1):
            for j in range(i, m + 1):
                L = [0]
                for k in range(1, n + 1):
                    si = get(1, i, k, j)
                    it = bisect.bisect_left(L, si - K)
                    if it != len(L):
                        res = max(res, si - L[it])
                    bisect.insort(L, si)
        return res
```


## 365. Water and Jug Problem  (GCD)

[Problem link](https://leetcode.com/problems/water-and-jug-problem/)

- Other's approach

The key point is: if z is the multiple of the `gcd`(Greatest common divisor 最大公约数) of x and y, it must be measurable.

```python
class Solution:
    def canMeasureWater(self, x: int, y: int, z: int) -> bool:
        if not z: 
            return True #edge case 
        
        def gcd(x, y): 
            """Return greatest common divisor via Euclidean algo"""
            if x < y:
                x, y = y, x
            while y:
                x, y = y, x%y
            return x
        
        return z <= x + y and z % gcd(x, y) == 0
```


## 367. Valid Perfect Square

[Problem link](https://leetcode.com/problems/valid-perfect-square/)

- My approach

Use binary search, the max num is 2**31-1, ant the int(sqrt(2**31-1)) is 46340. So we start from 46340/2 to do binary search.

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l = 0
        r = 46341
        
        m = (l+r) // 2
        last = m
        
        while True:
            if m * m == num:
                return True
            elif m * m < num:
                l = m
                m = (m+r) // 2
            else:
                r = m
                m = (l+m) // 2
            if last == m:
                return False
            last = m
```

Or we can start search at num//2.

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left=0
        right=num
        while left<=right:
            mid=(left+right)//2
            square=mid*mid
            if square == num:
                return True
            elif square>num:
                right=mid-1
            else:
                left=mid+1
        return False
```


## 368. Largest Divisible Subset

[Problem link](https://leetcode.com/problems/largest-divisible-subset/)

- My approach

Use dynamic programming, dp[i] stands for the largest divisible subset until nums[i].

```python
class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        nums.sort()
        dp = [[]] * len(nums)
        dp[0] = [nums[0]]
        
        for i in range(1, len(nums)):
            curr = [nums[i]]
            # Traverse nums[:i], is current nums[i] is divisible with dp[i][-1], it is divisible with all dp[i]
            for j in range(i):
                if nums[i] % dp[j][-1] == 0:
                    temp = dp[j] + [nums[i]]
                    if len(temp) > len(curr):
                        curr = temp
            dp[i] = curr

        res = []
        for l in dp:
            if len(l) > len(res):
                res = l
        return res
```

- Other's approach

We can find all the factors of n firstly. For every n, the largest divisible subset equals to the largest divisible subset of its factors plus current n.

```python
class Solution:
    def largestDivisibleSubset(self, nums):
        if not nums: return []
        
        nums.sort()
        def find_factors(n):
            factors = []
            for i in range(1, int(n**0.5)+1):
                if n % i == 0:
                    factors.append(i)
                    factors.append(n // i)
            return factors
            
        cache = dict()
        for n in nums:
            factors, subset = find_factors(n), []
            for f in factors:
                if f in cache:
                    if len(cache[f]) > len(subset):
                        subset = cache[f]
            cache[n] = subset + [n]
        return max(cache.values(), key=len)
```


## 371. Sum of Two Integers  (Other's approach)

[Problem link](https://leetcode.com/problems/sum-of-two-integers/)

- Other's approach

Use binary operation. From [this solution](https://leetcode.com/problems/sum-of-two-integers/discuss/699379/Python-Simple-bit-operations-solution-with-detailed-explanation)

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        ## RC ##
        ## APPROACH : BITWISE OPERATIONS ##
        ## LOGIC ##
        #   1. For any two numbers, if their binary representations are completely opposite, then XOR operation will directly produce sum of numbers ( in this case carry is 0 )
        #   2. what if the numbers binary representation is not completely opposite, XOR will only have part of the sum and remaining will be carry, which can be produced by and operation followed by left shift operation.
        #   3. For Example 18, 13 => 10010, 01101 => XOR => 11101 => 31 (ans found), and operation => carry => 0
        #   4. For Example 7, 5
        #   1 1 1                   1 1 1
        #   1 0 1                   1 0 1
        #   -----                   -----
        #   0 1 0   => XOR => 2     1 0 1  => carry => after left shift => 1 0 1 0
        #   2                                                              10
        # now we have to find sum of 2, 10 i.e a is replace with XOR result and b is replaced wth carry result
        # similarly repeating this process till carry is 0
        #   steps will be 7|5 => 2|10 => 8|4  => 12|0
        
		## TIME COMPLEXITY : O(1) ##
		## SPACE COMPLEXITY : O(1) ##
        
        # 32 bit mask in hexadecimal
        mask = 0xffffffff # (python default int size is not 32bit, it is very large number, so to prevent overflow and stop running into infinite loop, we use 32bit mask to limit int size to 32bit )
        while(b & mask > 0):
            carry = (a & b) << 1
            a = a ^ b
            b = carry
        return (a & mask) if b > 0 else a
```


## 372. Super Pow  (Recursing method)

[Problem link](https://leetcode.com/problems/super-pow/)

- Other's approach

Use recursing method, every time calculate a^b[-1].

```python
class Solution(object):
    def superPow(self, a, b):
        if len(b) == 1:
            return a ** b[0] % 1337
        return self.superPow(a, b[:-1]) ** 10 * a ** b[-1] % 1337
```

I was confused firstly that the number can only smaller than 2^64.


## 373. Find K Pairs with Smallest Sums  (Heap)

[Problem link](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)

- My approach

Save all the pairs in to a list then sort them by their sum.

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        
        res = []
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                res.append([nums1[i], nums2[j]])
        
        res.sort(key=sum)
        
        return res[:k]
```

- Other's approach

Use heap to sort them while adding pairs. The elements to sort is smaller than k, so this method can run faster.

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if nums1 == [] or nums2 == []:
            return []
        
        heap = []
        for j in range(len(nums2)):
            heapq.heappush(heap, (nums1[0]+nums2[j], (0, j)))

        result = []
        while len(result) < k and len(heap) > 0:
            # Every time append one line and only pop one pair
            curr = heapq.heappop(heap)
            result.append([nums1[curr[1][0]], nums2[curr[1][1]]])
            if curr[1][0]+1 < len(nums1):
                i = curr[1][0]+1
                j = curr[1][1]
                heapq.heappush(heap, (nums1[i]+nums2[j], (i, j)))
        
        return result
```
