---
layout: article
tags: Leetcode Python
title: Leetcode problems 21-40
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 21 to 40, writing in Python.

<!--more-->

## 21.Merge Two Sorted Lists

## Solution

[Problem Link](https://leetcode.com/problems/merge-two-sorted-lists/)

- My solution:

Main idea is adding all elements of one list to the other list.

Firstly, we need to check which list should be the list being added (check the head node value, and the smaller will be the goal).
Then traverse the sub list, compare each current value of the two list, if the value of sub list is larger than the goal list, 
add the current node of sub list after the current value of goal list.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        # Check which list should be the list to be added
        if l1.val >= l2.val:
            res = l_goal = l2
            sub_l = l1
        else:
            res = l_goal = l1
            sub_l = l2
        while sub_l:
            # For each list, we shoule create two pointers to store current nodes
            l_last = l_goal
            while l_goal and sub_l.val >= l_goal.val:
                l_last = l_goal
                l_goal = l_goal.next

            mid_sub = sub_l.next  # A middle pointer
            # Update nodes
            sub_l.next = l_last.next
            l_last.next = sub_l
            l_goal = sub_l
            sub_l = mid_sub
        return res
```

Beacuse we created two pointers for each list, and do a lot of magic assignment to update nodes, this solution is kind of complex.
Although ti's fast (beats 99%).

- Others' solution

One good solution is created a third list, and add the elements of two given lists to the third list

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # Create a head of third list
        l3 = ListNode(-1)
        head = l3
        while l1 and l2:
            # Add the smaller node of l1 and l2 into l3
            if l1.val < l2.val:
                l3.next = l1
                l1 = l1.next
            else:
                l3.next = l2
                l2 = l2.next
            l3 = l3.next
        # If there are remained nodes in l1 or l2
        if l1:
            l3.next=l1
        if l2:
            l3.next=l2
        return head.next
```

There is another way by using a recursing method
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next,l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l2.next,l1)
            return l2
```

### Conclusion

- When facing a problem, firstly should think about stylized method, such as recursing.


## 22.Generate Parentheses (Recursing)

[Problem Link](https://leetcode.com/problems/generate-parentheses/)

- My solution

Main idea: every time add a pair of parentheses together into string, add n times.

Ilustrate: First time add `'()'` into string, so the string is `'()'`. And then add `'()'` into `'()'`, there are three place to add.
So the result string canbe `'()()'`(add into first place) or `'(())'`(add into second place) or `'()()'`(add into third place), and
the first and the third are the same. So after adding two pair of parentheses, there are two strings in the answer list:`['()()', 
'(())']`. And there are 5 places to add the third parenthese into string (len(string) + 1).

After adding n times, you can get the answer.

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        if n == 0:
            return []
        res = {0: ['()']}
        # Add n times
        for i in range(1, n):
            res[i] = []
            last_f = res[i-1]
            # Add every string in the list
            for j in range(len(last_f)):
                # For each string, there are len(string)+1 places to insert new '()'
                for k in range(len(last_f[j])):
                    this_s = last_f[j][:k] + '()' + last_f[j][k:]
                    if this_s not in res[i]:
                        res[i].append(this_s)
        return res[n-1]
```

This solution is easy to understand, but has a poor performance (beats 5%)

- Other solution

This problem is also suitable for recursing method, but it's too difficult to understand others' recuring method.

Here is an easy understanding recursing resolution:
```python
class Solution(object):
    def generateParenthesis(self, n):
        # Add n times '(' and n times ')'
        def placeBracket(open_parens, closed_parens, current):
            global result
            # If both of them are zero, that means all of parentheses are ended over
            if closed_parens == 0 and open_parens == 0:
                result.append(''.join(current))
            # If closed_parens > open_parens, that means has added more '(' than ')'
            elif closed_parens > open_parens:
                # Here entends two ways, one way is add ')' after '(', like '()()'
                placeBracket(open_parens, closed_parens - 1, current + [')'])
                if open_parens > 0:
                    # And the other is here, add '(' after '(', like '(())'
                    placeBracket(open_parens - 1, closed_parens, current + ['('])
            # If closed_parens == open_parens (it's impossible that closed_parens < open_parens)
            # add a '(' into string
            else:
                placeBracket(open_parens - 1, closed_parens, current + ['('])

        global result
        result = []
        placeBracket(n, n, [])
        return result
```

We can paint a binary tree at the position of `elif`, one branch is add `(` after `(`, the other is add `)` after `(`

### Conclusion

- Reursing is an important method, but sometimes abstract. We can understand as recursing can divide the program into branches.


## 23.Merge K Sorted Lists

[Problem Link](https://leetcode.com/problems/merge-k-sorted-lists/)

- My solution

There is a problem named [Merge Two Sorted Lists](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/MergeTwoSortedLists.md) before, my idea is: do merge two lists method one by one.

Such as a list `l` has 4 listnodes, firstly, merge l[0] and l[1] and get the result l01. Them merge l01 and l[2], get the result l012, 
then merge l012 and l[3], the result l0123 is the final result.
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergetwo(self, l1, l2):
        res = head = ListNode(0)
        while l1 and l2:
            if l1.val >= l2.val:
                res.next = l2
                l2 = l2.next
            else:
                res.next = l1
                l1 = l1.next
            res = res.next
        if l1:
            res.next = l1
        elif l2:
            res.next = l2
        # print(head.next)
        return head.next
    
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if len(lists) == 0:
            return None
        if len(lists) == 1:
            return lists[0]
        res = None
        # Merge two lists one by one
        for i in range(len(lists)):
            res = self.mergetwo(res, lists[i])
        return res
```

But this method causes a problem: for each merging, list l1 will be longer and longer. So it will costs a lot of time.

There is an optimized approach for the approach above:
```python
class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        amount = len(lists)
        interval = 1
        # Here is a magic!
        while interval < amount:
            for i in range(0, amount - interval, interval * 2):
                lists[i] = self.merge2Lists(lists[i], lists[i + interval])
            interval *= 2
        return lists[0] if amount > 0 else None

    def merge2Lists(self, l1, l2):
        head = point = ListNode(0)
        while l1 and l2:
            if l1.val <= l2.val:
                point.next = l1
                l1 = l1.next
            else:
                point.next = l2
                l2 = l1
                l1 = point.next.next
            point = point.next
        if not l1:
            point.next=l2
        else:
            point.next=l1
        return head.next
```

There is a magic method in this approach. Every time, it combines n pairs of lists to merge (n is len(lists)/2*time).

For example, a given list with 6 elements. First time, merge l[0] with l[1], l[2] with l[3], l[4] with l[5], and the results are:
l01, l23, l45. Second time, merge l01 with l23, the result is l0123. Finally, merge l0123 and l45, and it's the final result.

By this way, we can recude merging times, and the list to merge will not be very long. So it can save time.

- Fastest approach

The fastest approach in Python is putting all node.val in a list, then sort the list. Finally create a new listnode.
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        nodes = []
        h = p = ListNode(0)
        for l in lists:
            while l:
                # Save all val into list
                nodes.append(l.val)
                l = l.next
        for x in sorted(nodes):
            # Create a new ListNode
            p.next = ListNode(x)
            p = p.next
        return h.next
```

### Conclusion

- Magic method to combine two elements together each time for a list:
```python
amount = len(lists)
        interval = 1
        while interval < amount:
            # Pay attention to 'amount - interval'
            for i in range(0, amount - interval, interval * 2):
                lists[i] = self.merge2Lists(lists[i], lists[i + interval])
            interval *= 2
```


## 24.Swap Nodes In Pairs

[Problem Link](https://leetcode.com/problems/swap-nodes-in-pairs/)

- My solution

This problem is not very difficult, it's just about delete and insert operation of linked list.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        h = a = ListNode(0)
        h.next = a.next = head
        while a.next:
            # To swap two nodes, firstly create two pointers of them: fir and sec
            fir = a.next
            sec = fir.next
            # If sec is None, means there is a single node at the end, just return
            if not sec:
                return h.next
            fir.next = sec.next
            sec.next = fir
            # After swapping them, we should connect the list together again
            a.next = sec
            a = fir
        return h.next
```

The other approches are the same as mine.



## 25.Reverse Nodes In K-Group

[Problem Link](https://leetcode.com/problems/reverse-nodes-in-k-group/)

- My solution

My idea is to store the linked list into a python list, and use the `list.reverse()` method.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        l = []
        while head:
            l.append(head.val)
            head = head.next
        res = []
        # Every time reverse the first k elements in l, then add into res
        while len(l) >= k:
            sub_l = l[:k]
            # print(sub_l)
            sub_l.reverse()
            res += sub_l
            # print(res)
            l = l[k:]
        # If there are elements remained (less than k), just add to the end
        if l:
            res += l
        # Create a new linked list
        h = n = ListNode(0)
        for i in res:
            n.next = ListNode(i)
            n = n.next
        return h.next
```

Beacues this approach creates some new lists, it will cost a larger memory usage.

This problem can also be solved by linked-list-method.
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if k <= 1:
            return head
        # Set a new head, and self.cut is a global variable to record current node
        self.cut = dummy = ListNode(0)
        # A function to reverse nodes from l to r
        def reverse(l, r):
            prev = None
            newFirst = l
            # Reverse linked node from l to r
            while l != r:
                l.next, l, prev = prev, l.next, l
            l.next = prev
            # Add the reversed linked node into result
            self.cut.next = r
            self.cut = newFirst
        
        newNext = head
        while newNext:
            l = r = newNext
            for i in range(k-1):
                r = r.next
                if not r:
                    break
                newNext = r.next
            # If there are less than k noeds, just add the remained linked list
            if not r:
                self.cut.next = l
                break
            
            reverse(l,r)
        return dummy.next
```

### Conclusion

- A magic method to reverse linked list:
```python
# Reverse linked node from l to r
while l != r:
    l.next, l, prev = prev, l.next, l
l.next = prev
# The head of new reversed linked list is l
```


## 26.Remove Duplicates From Sorted Array

[Problem Link](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

- My approach

It's an easy problem. Just remove the repeated elements of the array. But must modify the input array in-place.
So we can't simplily format it into a set.
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) < 1:
            return 0
        i = 1
        n = nums[0]
        while i < len(nums):
            # If this element is equal to the last, pop current element
            if nums[i] == n:
                nums.pop(i)
            else:
                n = nums[i]
                i += 1
        return len(nums)
```

- Official approach

It uses two pointers, when find a different element, modify current position. It doesn't change the length of the array, just 
put all the different elements in the first n positions (n is the return value).
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        j = 0
        for i in range(len(nums)):
            # When find a different element, modify current value
            if nums[j] != nums[i]:
                j += 1
                nums[j] = nums[i]
        return j+1
```


## 27.Remove Element

[Problem Link](https://leetcode.com/problems/remove-element/)

- My approach

It's also an easy problem. My idea is use `pop()` method.
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        while i < len(nums):
            # When find the val, pop it
            if nums[i] == val:
                nums.pop(i)
            else:
                i += 1
        return len(nums)
```

But this approcah changed the whole length of nums.

There is an approach like [Remove Duplicates From Sorted Array](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/RemoveDuplicatesFromSortedArray.md)
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        for j in range(len(nums)):
            # Put all elements that not val into front
            if nums[j] != val:
                nums[i] = nums[j]
                i += 1
        return i
```

And because we don't care the order of the return array, wo can also do like this:
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        n = len(nums)
        while i < n:
            # When find an element equal to val, put the last element into current position
            # and reduce the length number
            # It will return a reserve order
            if nums[i] == val:
                nums[i] = nums[n-1]
                n -= 1
            else:
                i += 1
        return n
```


## 28.Implement strStr()

[Problem link](https://leetcode.com/problems/implement-strstr/)

This is an easy problem, use Python method `index()` can immediately get the answer.
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

And it's also easy to traverse the string manually.
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if haystack == needle:
            return 0
        n = len(needle)
        for i in range(len(haystack)-n+1):
            if haystack[i:i+n] == needle:
                return i
        return -1
```


## 29.Divide Two Integers

[Problem link](https://leetcode.com/problems/divide-two-integers/)

Divide two numbers, and can't use divide or multiplication method. Firstly I want to cumulatively add divisor to dividend. 
But it exceeded.

So without divide and multiplication, if add can't pass, I don't know how to use other methods.

There is an approach from others.
```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        is_negative = (dividend < 0) != (divisor < 0)
        divisor, dividend = abs(divisor), abs(dividend)
        quotient = 0
        the_sum = divisor
        
        while the_sum <= dividend:
            current_quotient = 1
            # Every time get double 'the_sum', and double 'current_quotient',
            # if double 'the_sum' is larger than dividend, reduce the_sum from divident,
            # then do the same operation to the difference, until divident < divisor
            while (the_sum + the_sum) <= dividend:
                the_sum += the_sum
                current_quotient += current_quotient
            dividend -= the_sum
            the_sum = divisor
            quotient += current_quotient
            
        return min(2147483647, max(-quotient if is_negative else quotient, -2147483648))
```

This approach double current sum every time, like power operation, so it runs fast.

### Conclusion

- An operation about integer range
```python
# Return integer included in [2^32-1, -2^32]
return min(2147483647, max(result, -2147483648))
```


## 30.Substring With Concatenation Of All Words  (Other's approacg)


[Problem link](https://leetcode.com/problems/substring-with-concatenation-of-all-words/)

- My solution

This is a complex problem

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if len(s) == 0 or len(words) == 0:
            return []
        l = len(words[0])
        n = len(words)
        res = []
        for i in range(len(s)-l+1):
            if s[i:i+l] in words:
                # If there are less letters than the whole length of all words, break
                if len(s) - i < n*l:
                    break
                d = {}
                # Colletct all sub words in words[]
                for j in range(i, i+n*l, l):
                    current_s = s[j:j+l]
                    # print(current_s)
                    if current_s not in words:
                        break
                    else:
                        if current_s in d:
                            d[current_s] += 1
                        else:
                            d[current_s] = 1
                # print(d)
                is_ans = True
                for word in words:
                    # If a word in words doesn't appear in dict, means it's not proper
                    # and if the count of the word in words and in dict are different, means it's not proper
                    if word not in d.keys() or d[word] != words.count(word):
                        is_ans = False
                        break
                if is_ans:
                    res.append(i)
        return res
```

This approach doesn't perform very well, but I can't find another way.

There is an approach from others:
```python
from collections import defaultdict
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        solu = []
        # defaultdict set a dictionary with no keys but their default value as the argument given
        # in this case, it's int
        word_map = defaultdict(int)
        if len(s) == 0 or len(words) == 0:
            return solu
        # Store the words in a dictionary
        for word in words:
            word_map[word] += 1
        
        length = len(words[0])  # length of any word
        # Because every word has the same length, so we can traverse just in the range of length
        for i in range(0, length):
            start = i
            count = 0
            curr_word_map = defaultdict(int)

            for j in range(start, len(s)-length+1, length):
                subword = s[j:j+length]

                # check if the subword exists in the map
                if subword in word_map:
                    curr_word_map[subword] += 1
                    count += 1
                    # print("found:", subword)
                    # print("current word map:", curr_word_map)
                    # print("count: ", count)

                    # if current word count of some word is larger than 
                    # that of actual num of words, reduce count and move
                    # start pointer one length further
                    
                    ## He uses the 'start' like a pointer
                    ## and count every word, if find a word's number in current word map 
                    ## is larger than in given words list(word_map): reduce count and update start
                    while(curr_word_map[subword] > word_map[subword]):
                        removed = s[start:start+length]
                        print("removing:", removed)
                        curr_word_map[removed] -= 1
                        start += length
                        count -= 1
                    # if all words have been counted in this sequence, add
                    # the answer to result
                    
                    ## If every word count passed, and total count also passed,
                    ## means this sub of s is accorded given condition, add it to result
                    if count == len(words):
                        solu.append(start)
                        # then we move one word length further and continue our
                        # search, update start
                        removed = s[start:start+length]
                        curr_word_map[removed] -= 1
                        start += length
                        count -= 1
                        #print("adding solu", start)

                else:
                    count = 0
                    start = j + length
                    curr_word_map.clear()
        return solu
```

This approach runs fast because it doesn't traverse s by every character, pay attention to `for i in range(0, length):`, 
it just traverse in the length of word, and set a pointer 'start', all the words back are according to this pointer.

### Knowledge

- defaultdict in Python

`defaultdict` is an object like dictionary, but it's value is set by default as the argument given,like:
```python
from collections import defaultdict

d = defaultdict(int)  # set the defaule value as int type
```


## 31.Next Permutation

[Problem link](https://leetcode.com/problems/next-permutation/)

This is the first timt(maybe?) that my idea perfectly matches the offical approach.

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        for i in range(n-1):
            # If a number is larger than it'f front number,there is something we can do
            if nums[n-i-1] > nums[n-i-2]:
                # If they are the last two numbers, just change them
                if i == 0:
                    nums[-1], nums[-2] = nums[-2], nums[-1]
                    return
                # If they are not the last two numbers
                else:
                    front = nums[n-i-2]   # record the front number
                    # Set a dictionary to store the index of nums
                    d = {}
                    for index, value in enumerate(nums[n-i-1:]):
                        d[value] = index
                    # Set a sorted lis 'l' to find the next larger number than front
                    l = list(d.keys())
                    l.sort()

                    # We should find the next larger number than the 'front' number nums[n-i-2],
                    # change them, and sort the rest list, just like the answer of [3,2,5,4,3,2,1]
                    # is [3,3,1,2,2,4,5] (something happened at '[2,5]')

                    # Find the number larger than 'front', then change
                    # this number and 'front' in nums
                    for k in range(len(l)):
                        if l[k] > front:
                            change_i = k
                            break
                    # Find index of the number to change
                    target_i = d[l[change_i]]
                    # Change them
                    nums[n-i-2], nums[target_i+n-i-1] = nums[target_i+n-i-1], nums[n-i-2]

                    # Sort the rest
                    for j in range((i+1)//2):
                        nums[n-i-1+j], nums[n-1-j] = nums[n-1-j], nums[n-i-1+j]
                    return
        nums.sort()
        # pass
```

As the comment, to deal with this problem, we should traverse the list from right to left, until finding a pair of number that 
`nums[i-1] < nums[i]`, and then find the next larger number in nums[i:], then swap the 'next-larger-number' and nums[i-1], then 
sort the new n[i:] with ascending order. And that's the result.

### Knowledge

- Lexicographically next greater permutation of numbers
In chinese, it means '字典序全排列'. For example, give a list `123`, it's lexicographically permutation is:
`123、132、213、231、312、321`,and it must be in this order.


## 32.Longest Valid Parentheses

[Problem link](https://leetcode.com/problems/longest-valid-parentheses/)

Firstly I thought it in a complex way, and get confused.

There are two good approaches provided by official.

- 1.Stack

Set a stack to store index of every char in s, when find a '(', just push in stack. And when find a ')', pop the top of stack, 
then calculte the difference between current index and the new top (this new pop stands for the index before the 
`start` of a valid sub_string)
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # Firstly push a '-1' in stack, to avoid the situation 's[0] == "("'
        stack = [-1,]
        res = num = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop(-1)   # This makes stack[-1] is always the last index before the start '('
                if stack == []:
                    stack.append(i)
                else:
                    # stack[-1] is the index before the start of this whole sub valid parentheses
                    res = max(res, i - stack[-1])
        return res
```

The magic is store `the index before 'start "("'`

- 2.Left and right

This is a smart approach which traverses 's' two times, one from left to right, one from right to left.

For the traversing from left to right, count the number of '('(l) and ')'(r). When `l=r`, means that this a valid sub string. When `r>l`, 
meand current sub string is not valid, then reset `l=r=0`, continue traverse.

And from right to left is same, but the judgement is `l>r`
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        res = 0
        l = r = 0
        for i in range(len(s)):
            if s[i] == '(':
                l += 1
            else:
                r += 1
            # When l = r, length = 2*r
            if l == r:
                res = max(res, 2*r)
            # If r > l, reset
            elif r > l:
                l = r = 0
        l = r = 0
        for i in range(len(s)):
            n = len(s) - i -1
            if s[n] == ')':
                r += 1
            else:
                l += 1
            if l == r:
                res = max(res, 2*l)
            elif l > r:
                l = r = 0
        return res
```

This approach can save space.


## 33.Search In Rotated Sorted Array

[Problem link](https://leetcode.com/problems/search-in-rotated-sorted-array/)

- My approach

Because it's a sorted array, therre are no duplicated elements, the simplest way in Python is:
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        try:
            return nums.index(target)
        except:
            return -1
```

But obviously that's not the intention of questioners.

The second approach uses a lot of `if-else` to judge situations:
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        m = max(nums)
        # If the first number is bigger than the last, means the max number is in middle
        if nums[0] > nums[-1]:
            # If target < nums[0], means if exist, target must between max anf the last number ([max:-1])
            if nums[0] > target:
                if nums[-1] < target:
                    return -1
                else:
                    for i in range(len(nums)):
                        n = nums[len(nums)-i-1]
                        if n == target:
                            return len(nums) - i - 1
                        if n == m:
                            return -1
            # If target =< nums[0], means target is in [0:max]
            else:
                for i in range(len(nums)):
                    if nums[i] == target:
                        return i
                    if nums[i] == max:
                        return -1
        # If nums[0] <= nums[-1], means this array is in asending order, just traverse it
        else:
            for i in range(len(nums)):
                if nums[i] == target:
                    return i
        return -1
```

This approach can run very fast(beats 90%). But it's hard to calculate its runtime complexity.

- Other approach

In the topic, it mentioned the runtime complexity must be in `O(log n)`. O(log n) usually stands with `dichotomy`（二分法）, 
there is a code:
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)-1
        
        while left<=right:
            mid =int((left+right)/2)
            if nums[mid] == target:
                return mid
            elif nums[left]<=nums[mid]:
                if nums[left]<=target< nums[mid]:
                    right = mid-1
                else:
                    left = mid+1
            else:
                if nums[mid]<target<=nums[right]:
                    left = mid+1
                else:
                    right = mid-1
        return -1
```

### Conclusioin

- O(log n) runtime complexity and dichotomy.


## 34.Find First And Last Position Of Element In Sorted Array  (Official approach)

[Problem link](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

- My approach

This is also a problem asks to be solved by 'O log(n)` runtime complexity.

So use dichotomy(or binary search) method.
```python
class Solution:
    # When in main function find an element == target, 
    # use this function to find the result interval
    def findResult(self, nums, index, target):
        lt = rt = index
        while lt >= 0 and nums[lt] == target:
            lt -= 1
        while rt <= len(nums)-1 and nums[rt] == target:
                rt += 1
        return [lt+1, rt-1]
    
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0:
            return [-1, -1]
        l = 0
        r = len(nums) - 1
        if l == r:
            if nums[0] == target:
                return [0, 0]
            else:
                return [-1, -1]
        
        while l < r:
            # If target > max or target < min, means target is not in nums
            if target > nums[r] or target < nums[l]:
                return [-1, -1]
            # If nums[l] or nums[r] or nums[mid] == target, call findResult() to get the answer
            if nums[l] == target:
                res = self.findResult(nums, l, target)
                return res
            if nums[r] == target:
                res = self.findResult(nums, r, target)
                return res
            mid = (l + r) // 2
            if nums[mid] == target:
                res = self.findResult(nums, mid, target)
                return res
            # Update left and right
            elif nums[mid] > target >= nums[l]:
                r = mid - 1
            elif nums[mid] < target <= nums[r]:
                l = mid + 1

        return [-1, -1]   
```

This approach is a little complex, it doesn't avoid come special situations such as `nums=[]`.

- Offical approach

Offical approach also uses binary search, but there is a magic logic, you should go to the page to see 
the [picture demonstrate](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/) to understand better.

```python
class Solution:
    # returns leftmost (or rightmost) index at which `target` should be inserted in sorted
    # array `nums` via binary search.
    def extreme_insertion_index(self, nums, target, left):
        # If left is True, means finding the left edge,
        # is left is False, means finding the right edge
        lo = 0
        hi = len(nums)

        while lo < hi:
            mid = (lo + hi) // 2
            if nums[mid] > target or (left and target == nums[mid]):
                hi = mid
            else:
                lo = mid+1

        return lo

    def searchRange(self, nums, target):
        left_idx = self.extreme_insertion_index(nums, target, True)

        # assert that `left_idx` is within the array bounds and that `target`
        # is actually in `nums`.
        
        # Why this can avoid the special situations??
        if left_idx == len(nums) or nums[left_idx] != target:
            return [-1, -1]

        return [left_idx, self.extreme_insertion_index(nums, target, False)-1]
```


## 35.Search Insert Position

[Problem link](https://leetcode.com/problems/search-insert-position/)

A very easy problem
```
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if nums[i] >= target:
                return i
        return len(nums)
```

Maybe you can try binary search method, but it's a little complex in code.


## 36.Valid Sodoku  (A magic method)

[Problem link](https://leetcode.com/problems/valid-sudoku/)

- My approach

Just set every sub areas(lines, columns and 3x3 squares) into a list. Then use `count()` method, if count of some element is larger than 1,
return False.

```python
class Solution:
    # A function to check if there is a element appears more than once
    def jud_list(self, l):
        for i in l:
            if i != '.' and l.count(i) > 1:
                return False
        return True
    
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        # Lines
        for sub_b in board:
            res = self.jud_list(sub_b)
            if not res:
                return False
        # Columns
        for j in range(9):
            sub_l = [l[j] for l in board]
            res = self.jud_list(sub_l)
            if not res:
                return False
        # 3x3 squares
        for a in range(3):
            for b in range(3):
                sub_s = board[3*a][3*b:3*(b+1)] + board[3*a+1][3*b:3*(b+1)] + board[3*a+2][3*b:3*(b+1)]
                # print(sub_s)
                res = self.jud_list(sub_s)
                if not res:
                    return False
        return True
```

That's a force method, but unexpectedly, it has a good performance(beats 99%).

- Other's approach

There is a very concise approach
```
class Solution:
    def isValidSudoku(self, board):
        seen = []
        # For each element, store them in a tuple with their serial number of lines, columns and 3x3 squares
        for i, row in enumerate(board):
            for j, c in enumerate(row):
                if c != '.':
                    seen += [(c,j),(i,c),(i//3,j//3,c)]
        # Beacuse tuple is a unchangeable object, we can use set() method to translate the list into a set,
        # and if their length are different, return False
        return len(seen) == len(set(seen))
```

He uses a magic way to store elements with their unique `serial number(line, column and 3x3 square)`. And then use `set()` method 
to check if there are same elements with same serial number.


## 37.Sudoku Solver  (Recursing)

[Problem link](https://leetcode.com/problems/sudoku-solver/)

This is a complex problem, the best way is recursing. Because we need to try every position for every number, 
and in this process, we must record the status. So the traceback method is a good way.
```python
from collections import defaultdict
class Solution:
    def solveSudoku(self, board):
        digits = set(map(str,range(1, 10)))
        r, c = defaultdict(set), defaultdict(set) # use r as the set for 3x3 box
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    r[i].add(board[i][j])
                    c[j].add(board[i][j])
                    r[i//3, j//3].add(board[i][j])
        
        def try_position(i, j):
            # i stands for rows, j stands for columns
            if i > 8: return True
            
            if j == 8:
                next_i = i + 1
                next_j = 0
            else:
                next_i = i
                next_j = j + 1
            # If this positioin has already been filt, goto next
            if board[i][j] != '.':
                return try_position(next_i, next_j)
            
            # filter the available numbers
            cands = digits - r[i] - c[j] - r[i//3, j//3]
            if not cands: 
                return False

            for val in cands:
                board[i][j] = val
                r[i].add(val)
                c[j].add(val)
                r[i//3, j//3].add(val)
                
                # If this number is suitable, go to try next position
                if try_position(next_i, next_j):
                    return True
                # If it's not suitable, reset this positoin to '.'
                else:
                    board[i][j] = '.'
                    r[i].remove(val)
                    c[j].remove(val)
                    r[i//3, j//3].remove(val)
            
            return False
                        
        try_position(0, 0)
```

The magic of recuring is that we can easily record the running status. For the problem which needs to try times by times, 
it's a easy way. 

But actually, it's difficult to design.

### Conclusion

- A good method `set()`


## 38.Count And Say

[Problem link](https://leetcode.com/problems/count-and-say/)

Finally I can write a recursing program. That's a big progress.

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        def giveAns(t, s):
            if t == n:
                return s
            count = 1
            sub_s = ''
            for i in range(len(s)):
                # If this is the last char, add to sub_s and go to next layer
                if i == len(s) - 1:
                    sub_s += (str(count) + s[i])
                    return giveAns(t+1, sub_s)
                if s[i+1] == s[i]:
                    count += 1
                else:
                    sub_s += (str(count) + s[i])
                    count = 1
        return giveAns(1, '1')
```

A good training of recursing.


## 39.Combination Sum

[Problem link](https://leetcode.com/problems/combination-sum/)

- My approach

Also a recursing method.
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        # Firstly, sort the list
        candidates.sort()
        res = []
        
        def subSum(l, t, sub_res):
            for i in range(len(l)):
                n = t - l[i]
                # n == 0 means find a result, append it into res
                if n == 0:
                    sub_res.append(l[i])
                    # Because 'append()' is a in-place method, here I make a copy of sub_res,
                    # or next operation for sub_res will change res
                    res_app = sub_res[:]
                    # Check if current res_app has already existed
                    res_app.sort()
                    if res_app not in res:
                        res.append(res_app)
                    # After add sub_res to res, we need to revert sub_res, 
                    # such as in this layer, sub_res is [2, 2, 2] at the begining, target is 8,
                    # so we add [2, 2, 2, 2] into res. But when the program is going on, 
                    # is must start with [2, 2, 2], not the result [2, 2, 2, 2]. 
                    # So we need to pop the last element which we added just now.
                    sub_res.pop(-1)
                # If n > 0, means the program can go further
                elif n > 0:
                    sub_res.append(l[i])
                    subSum(l, n, sub_res)
                    sub_res.pop(-1)
                else:
                    break
        subSum(candidates, target, [])
        return res
```

This code works, but it has some excess operation. And we can improve it.

- Optimized approach
```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        # Functions build in a class can't see the local variable here, 
        # so change it into self.res
        self.res = []
        
        def subSum(l, t, sub_res):
            for i in range(len(l)):
                n = t - l[i]
                if n == 0:
                    # Instead of using in-place method 'append()', simplely use '+' for list,
                    # so we don't need to create a copy or do 'pop()'
                    self.res += [sub_res+[l[i]]]
                elif n > 0:
                    # Pay attention to the 'l[i:]', 
                    # for next layer program, we just need to start traversing at current element,
                    # that can save time, and avoid duplication.
                    subSum(l[i:], n, sub_res+[l[i]])
                else:
                    break
        subSum(candidates, target, [])
        return self.res             
```

### Knowledge

- 1.`append()` is an in-place method, be careful when using it. You can use '+' for list instead.

- 2.Common function(without 'self') created in class can't see the class's local variable.


## 40.Combination Sum 2

[Problem link](https://leetcode.com/problems/combination-sum-ii/)

- My approach

This problem is as same as [Combination sum](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/CombinationSum.md). We can also use a recursing method.
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        self.res = []
        candidates.sort()
        
        def subSum(l, t, sub_res):
            for i in range(len(l)):
                n = t - l[i]
                if n == 0:
                    res_app = sub_res+[l[i]]
                    if res_app not in self.res:
                        self.res += [res_app]
                    break
                elif n > 0:
                    # Because every elememt can be used just once, so the next layer start with l[i+1]
                    subSum(l[i+1:], n, sub_res+[l[i]])
                else:
                    break
        subSum(candidates, target, [])
        return self.res
```

This approach doesn't run very fast(beats 70%). Because there may be same elements, that will create repeated results.

There is an other's faster approach.
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        
        if not candidates:
            return []
        candidates.sort()
        n = len(candidates)
        res = []
        
        def backtrack(i, tmp_sum, tmp_list):
            if tmp_sum == target:
                res.append(tmp_list)
                return
            for j in range(i, n):
                if tmp_sum + candidates[j] > target:
                    break
                # This 'continue' can avoid repeated elements
                if j > i and candidates[j] == candidates[j-1]:
                    continue
                backtrack(j + 1, tmp_sum + candidates[j], tmp_list + [candidates[j]])
        
        backtrack(0, 0, [])
        return res
```


