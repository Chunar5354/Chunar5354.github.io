---
layout: article
tags: Leetcode Python
title: Leetcode problems 281-300
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 281 to 300, writing in Python.

<!--more-->

## 282. Expression Add Operators  (Official solution)

[Problem link](https://leetcode.com/problems/expression-add-operators/)

- My approach

My idea is firstly create all the possible expressions for the given num. Then use the method of [Basic Calculator 2](https://leetcode.com/problems/basic-calculator-ii/) 
to calculate the expression.

```python
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        if not num:
            return []
        if num == str(target):
            return [num]

        res = set()
        def helper(idx, exp):
            if idx >= len(num):
                if self.calculate(exp) == target:
                    res.add(exp[:-1])
                return
            # 0 can't be at start of a number
            if num[idx] == '0':
                for e in '+-*':
                    helper(idx+1, exp+num[idx]+e)
            else:
                for i in range(idx, len(num)):
                    for e in '+-*':
                        helper(i+1, exp+num[idx:i+1]+e)
        helper(0, '')
        return res
    
    
    def calculate(self, s: str) -> int:
        num, stack, sig = 0, [], '+'
        for i in s:
            if i in '0123456789':
                num = 10 * num + int(i)
            if i in '+-*/':
                if sig == '+':
                    stack.append(num)
                elif sig == '-':
                    stack.append(-num)
                elif sig == '*':
                    stack.append(stack.pop() * num)
                sig = i
                num = 0 
        return sum(stack)   
```

- Official solution

```python
class Solution:
    def addOperators(self, num: 'str', target: 'int') -> 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append("".join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand > 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
```


## 283. Move Zeroes

[Problem link](https://leetcode.com/problems/move-zeroes/)

- My approach

My idea is using two pointers. z stands for the index of 0, and p stands for the index of non-zero after z. Each time locating z and p, swap them.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        z = 0
        while z < len(nums) and nums[z] != 0:
            z += 1
        # p must after z 
        p = z
        while p < len(nums) and nums[p] == 0:
            p += 1
            
        while p < len(nums):
            if nums[p] != 0 and nums[z] == 0:
                nums[z], nums[p] = nums[p], nums[z]
            if nums[p] == 0:
                p += 1
            if nums[z] != 0:
                z += 1
```

- Official approach

The method of two pointers can be optimized.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p = 0
        z = 0
            
        while p < len(nums):
            if nums[p] != 0:
                nums[z], nums[p] = nums[p], nums[z]
                z += 1
            p += 1
```

Here z stands for the last non-zero number or the first 0. When p is a non-zero number, swap them.


## 284. Peeking Iterator

[Problem link](https://leetcode.com/problems/peeking-iterator/)

- My approach

Firstly save the values of iterator into a list. And set a index to achieve the next and peek operation.

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = []
        while iterator.hasNext():
            self.iterator.append(iterator.next())
        self.idx = 0
        

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        p = self.next()
        self.idx -= 1
        return p
        

    def next(self):
        """
        :rtype: int
        """
        self.idx += 1
        return self.iterator[self.idx-1]
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.idx < len(self.iterator)
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

- Other's approach

The method above needs an extra list to store the values. If we use a varaiable to keep the result of next(), we can achieve the peek() operation. That has only O(1) space complexity.

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = iterator
        self.prev = None
        

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        if not self.prev:
            if self.iterator.hasNext():
                self.prev = self.iterator.next()
        return self.prev
        

    def next(self):
        """
        :rtype: int
        """
        if not self.prev:
            return self.iterator.next()
        else:
            curr = self.prev
            self.prev = None
            return curr
        

    def hasNext(self):
        """
        :rtype: bool
        """
        if self.prev:
            return True
        return self.iterator.hasNext()
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```


## 287. Find the Duplicate Number  (Tortoise and the hare)

[Problem link](https://leetcode.com/problems/find-the-duplicate-number/)

- My approach

Because the question asks to solve the problem in O(1) space somplex and less than O(n^2) time complex, I didn't find out the answer.

- Official solution

Use the same method of [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) (Tortoise and the Hareï¼‰.

Think the array as a linked list, nums[i] means i.next.

```python
class Solution:
    def findDuplicate(self, nums):
        # Find the intersection point of the two runners.
        tortoise = hare = nums[0]
        while True:
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            if tortoise == hare:
                break

        
        # Find the "entrance" to the cycle.
        tortoise = nums[0]
        while tortoise != hare:
            tortoise = nums[tortoise]
            hare = nums[hare]
        
        return hare
```

For more explinations, please see the [official solition](https://leetcode.com/problems/find-the-duplicate-number/solution/)


## 289. Game of Life

[Problem link](https://leetcode.com/problems/game-of-life/)

- My approach

Firstly create a copy of board, and check every cell by he rules to modify board.

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        m = len(board)
        n = len(board[0])
        
        temp = []
        for i in range(m):
            temp.append(board[i][:])
            
        def ifLive(r, c):
            if r < 0 or c < 0 or r >= m or c >= n:
                return 0
            else:
                return temp[r][c]
        
        
        for i in range(m):
            for j in range(n):
                s = sum(ifLive(i+d[0], j+d[1]) for d in directions)
                if temp[i][j] == 1:
                    if s == 2 or s == 3:
                        board[i][j] = 1
                    else:
                        board[i][j] = 0
                else:
                    if s == 3:
                        board[i][j] = 1         
```

To get O(1) space complex, we can modify board in-place. If current cell is 0 but will change to 1, we set it to -1, and if current cell is 1 and will change to 0, we set it to 2.
After modifying by the rules, traverse board and change 2 to 0, and -1 to 1.

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        m = len(board)
        n = len(board[0])
        
        def ifLive(r, c):
            if r < 0 or c < 0 or r >= m or c >= n:
                return 0
            else:
                if board[r][c] > 0:
                    return 1
                else:
                    return 0
        
        
        for i in range(m):
            for j in range(n):
                s = sum(ifLive(i+d[0], j+d[1]) for d in directions)
                if board[i][j] == 1:
                    if s < 2 or s > 3:
                        board[i][j] = 2  # current 1 and need to be changed to 0
                else:
                    if s == 3:
                        board[i][j] = -1  # current 0 and need to be changed to 1
        
        for i in range(m):
            for j in range(n):
                if board[i][j] == 2:
                    board[i][j] = 0
                if board[i][j] == -1:
                    board[i][j] = 1
```


## 290. Word Pattern

[Problem link](https://leetcode.com/problems/word-pattern/)

- My approach

Firstly split the ste with whitespace. Then create two dictionaries to save the map from pattern to str and from str to pattern. If there is a map different with the existing map, 
return False.

```python
class Solution:
    def wordPattern(self, pattern: str, _str: str) -> bool:
        l = _str.split(' ')
        if len(l) != len(pattern):
            return False
        
        dp = {}
        dl = {}
        for i in range(len(l)):
            if pattern[i] not in dp:
                dp[pattern[i]] = l[i]
            else:
                if l[i] != dp[pattern[i]]:
                    return False
            
            if l[i] not in dl:
                dl[l[i]] = pattern[i]
            else:
                if pattern[i] != dl[l[i]]:
                    return False
        return True
```

- Official solution

We can solve this problem by using only one dictionary. Save the pattern and words from str in a same dictionary as key, and their values are the indexes. If the key is already in 
dictionary we do not change it, else dic[key] = index. And if current pattern and word have different values, return False.

```python
class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        map_index = {}
        words = str.split()
        
        if len(pattern) != len(words):
            return False
        
        for i in range(len(words)):
            c = pattern[i]
            w = words[i]

            char_key = 'char_{}'.format(c)
            char_word = 'word_{}'.format(w)
            
            if char_key not in map_index:
                map_index[char_key] = i
            
            if char_word not in map_index:
                map_index[char_word] = i 
            
            if map_index[char_key] != map_index[char_word]:
                return False
        
        return True
```

