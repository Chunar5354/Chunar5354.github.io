---
layout: article
tags: Leetcode Python
title: Leetcode problems 281-300
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 281 to 300, writing in Python.

<!--more-->

## 282. Expression Add Operators  (Official solution)

[Problem link](https://leetcode.com/problems/expression-add-operators/)

- My approach

My idea is firstly create all the possible expressions for the given num. Then use the method of [Basic Calculator 2](https://leetcode.com/problems/basic-calculator-ii/) 
to calculate the expression.

```python
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        if not num:
            return []
        if num == str(target):
            return [num]

        res = set()
        def helper(idx, exp):
            if idx >= len(num):
                if self.calculate(exp) == target:
                    res.add(exp[:-1])
                return
            # 0 can't be at start of a number
            if num[idx] == '0':
                for e in '+-*':
                    helper(idx+1, exp+num[idx]+e)
            else:
                for i in range(idx, len(num)):
                    for e in '+-*':
                        helper(i+1, exp+num[idx:i+1]+e)
        helper(0, '')
        return res
    
    
    def calculate(self, s: str) -> int:
        num, stack, sig = 0, [], '+'
        for i in s:
            if i in '0123456789':
                num = 10 * num + int(i)
            if i in '+-*/':
                if sig == '+':
                    stack.append(num)
                elif sig == '-':
                    stack.append(-num)
                elif sig == '*':
                    stack.append(stack.pop() * num)
                sig = i
                num = 0 
        return sum(stack)   
```

- Official solution

```python
class Solution:
    def addOperators(self, num: 'str', target: 'int') -> 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append("".join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand > 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
```


## 283. Move Zeroes

[Problem link](https://leetcode.com/problems/move-zeroes/)

- My approach

My idea is using two pointers. z stands for the index of 0, and p stands for the index of non-zero after z. Each time locating z and p, swap them.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        z = 0
        while z < len(nums) and nums[z] != 0:
            z += 1
        # p must after z 
        p = z
        while p < len(nums) and nums[p] == 0:
            p += 1
            
        while p < len(nums):
            if nums[p] != 0 and nums[z] == 0:
                nums[z], nums[p] = nums[p], nums[z]
            if nums[p] == 0:
                p += 1
            if nums[z] != 0:
                z += 1
```

- Official approach

The method of two pointers can be optimized.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p = 0
        z = 0
            
        while p < len(nums):
            if nums[p] != 0:
                nums[z], nums[p] = nums[p], nums[z]
                z += 1
            p += 1
```

Here z stands for the last non-zero number or the first 0. When p is a non-zero number, swap them.
