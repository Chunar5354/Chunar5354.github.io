---
layout: article
tags: Leetcode Python
title: Leetcode problems 281-300
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 281 to 300, writing in Python.

<!--more-->

## 282. Expression Add Operators  (Official solution)

[Problem link](https://leetcode.com/problems/expression-add-operators/)

- My approach

My idea is firstly create all the possible expressions for the given num. Then use the method of [Basic Calculator 2](https://leetcode.com/problems/basic-calculator-ii/) 
to calculate the expression.

```python
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        if not num:
            return []
        if num == str(target):
            return [num]

        res = set()
        def helper(idx, exp):
            if idx >= len(num):
                if self.calculate(exp) == target:
                    res.add(exp[:-1])
                return
            # 0 can't be at start of a number
            if num[idx] == '0':
                for e in '+-*':
                    helper(idx+1, exp+num[idx]+e)
            else:
                for i in range(idx, len(num)):
                    for e in '+-*':
                        helper(i+1, exp+num[idx:i+1]+e)
        helper(0, '')
        return res
    
    
    def calculate(self, s: str) -> int:
        num, stack, sig = 0, [], '+'
        for i in s:
            if i in '0123456789':
                num = 10 * num + int(i)
            if i in '+-*/':
                if sig == '+':
                    stack.append(num)
                elif sig == '-':
                    stack.append(-num)
                elif sig == '*':
                    stack.append(stack.pop() * num)
                sig = i
                num = 0 
        return sum(stack)   
```

- Official solution

```python
class Solution:
    def addOperators(self, num: 'str', target: 'int') -> 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append("".join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand > 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
```


## 283. Move Zeroes

[Problem link](https://leetcode.com/problems/move-zeroes/)

- My approach

My idea is using two pointers. z stands for the index of 0, and p stands for the index of non-zero after z. Each time locating z and p, swap them.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        z = 0
        while z < len(nums) and nums[z] != 0:
            z += 1
        # p must after z 
        p = z
        while p < len(nums) and nums[p] == 0:
            p += 1
            
        while p < len(nums):
            if nums[p] != 0 and nums[z] == 0:
                nums[z], nums[p] = nums[p], nums[z]
            if nums[p] == 0:
                p += 1
            if nums[z] != 0:
                z += 1
```

- Official approach

The method of two pointers can be optimized.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p = 0
        z = 0
            
        while p < len(nums):
            if nums[p] != 0:
                nums[z], nums[p] = nums[p], nums[z]
                z += 1
            p += 1
```

Here z stands for the last non-zero number or the first 0. When p is a non-zero number, swap them.


## 284. Peeking Iterator

[Problem link](https://leetcode.com/problems/peeking-iterator/)

- My approach

Firstly save the values of iterator into a list. And set a index to achieve the next and peek operation.

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = []
        while iterator.hasNext():
            self.iterator.append(iterator.next())
        self.idx = 0
        

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        p = self.next()
        self.idx -= 1
        return p
        

    def next(self):
        """
        :rtype: int
        """
        self.idx += 1
        return self.iterator[self.idx-1]
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.idx < len(self.iterator)
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

- Other's approach

The method above needs an extra list to store the values. If we use a varaiable to keep the result of next(), we can achieve the peek() operation. That has only O(1) space complexity.

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = iterator
        self.prev = None
        

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        if not self.prev:
            if self.iterator.hasNext():
                self.prev = self.iterator.next()
        return self.prev
        

    def next(self):
        """
        :rtype: int
        """
        if not self.prev:
            return self.iterator.next()
        else:
            curr = self.prev
            self.prev = None
            return curr
        

    def hasNext(self):
        """
        :rtype: bool
        """
        if self.prev:
            return True
        return self.iterator.hasNext()
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```


## 287. Find the Duplicate Number  (Tortoise and the hare)

[Problem link](https://leetcode.com/problems/find-the-duplicate-number/)

- My approach

Because the question asks to solve the problem in O(1) space somplex and less than O(n^2) time complex, I didn't find out the answer.

- Official solution

Use the same method of [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) (Tortoise and the Hareï¼‰.

Think the array as a linked list, nums[i] means i.next.

```python
class Solution:
    def findDuplicate(self, nums):
        # Find the intersection point of the two runners.
        tortoise = hare = nums[0]
        while True:
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            if tortoise == hare:
                break

        
        # Find the "entrance" to the cycle.
        tortoise = nums[0]
        while tortoise != hare:
            tortoise = nums[tortoise]
            hare = nums[hare]
        
        return hare
```

For more explinations, please see the [official solition](https://leetcode.com/problems/find-the-duplicate-number/solution/)


## 289. Game of Life

[Problem link](https://leetcode.com/problems/game-of-life/)

- My approach

Firstly create a copy of board, and check every cell by he rules to modify board.

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        m = len(board)
        n = len(board[0])
        
        temp = []
        for i in range(m):
            temp.append(board[i][:])
            
        def ifLive(r, c):
            if r < 0 or c < 0 or r >= m or c >= n:
                return 0
            else:
                return temp[r][c]
        
        
        for i in range(m):
            for j in range(n):
                s = sum(ifLive(i+d[0], j+d[1]) for d in directions)
                if temp[i][j] == 1:
                    if s == 2 or s == 3:
                        board[i][j] = 1
                    else:
                        board[i][j] = 0
                else:
                    if s == 3:
                        board[i][j] = 1         
```

To get O(1) space complex, we can modify board in-place. If current cell is 0 but will change to 1, we set it to -1, and if current cell is 1 and will change to 0, we set it to 2.
After modifying by the rules, traverse board and change 2 to 0, and -1 to 1.

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
        m = len(board)
        n = len(board[0])
        
        def ifLive(r, c):
            if r < 0 or c < 0 or r >= m or c >= n:
                return 0
            else:
                if board[r][c] > 0:
                    return 1
                else:
                    return 0
        
        
        for i in range(m):
            for j in range(n):
                s = sum(ifLive(i+d[0], j+d[1]) for d in directions)
                if board[i][j] == 1:
                    if s < 2 or s > 3:
                        board[i][j] = 2  # current 1 and need to be changed to 0
                else:
                    if s == 3:
                        board[i][j] = -1  # current 0 and need to be changed to 1
        
        for i in range(m):
            for j in range(n):
                if board[i][j] == 2:
                    board[i][j] = 0
                if board[i][j] == -1:
                    board[i][j] = 1
```


## 290. Word Pattern

[Problem link](https://leetcode.com/problems/word-pattern/)

- My approach

Firstly split the ste with whitespace. Then create two dictionaries to save the map from pattern to str and from str to pattern. If there is a map different with the existing map, 
return False.

```python
class Solution:
    def wordPattern(self, pattern: str, _str: str) -> bool:
        l = _str.split(' ')
        if len(l) != len(pattern):
            return False
        
        dp = {}
        dl = {}
        for i in range(len(l)):
            if pattern[i] not in dp:
                dp[pattern[i]] = l[i]
            else:
                if l[i] != dp[pattern[i]]:
                    return False
            
            if l[i] not in dl:
                dl[l[i]] = pattern[i]
            else:
                if pattern[i] != dl[l[i]]:
                    return False
        return True
```

- Official solution

We can solve this problem by using only one dictionary. Save the pattern and words from str in a same dictionary as key, and their values are the indexes. If the key is already in 
dictionary we do not change it, else dic[key] = index. And if current pattern and word have different values, return False.

```python
class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        map_index = {}
        words = str.split()
        
        if len(pattern) != len(words):
            return False
        
        for i in range(len(words)):
            c = pattern[i]
            w = words[i]

            char_key = 'char_{}'.format(c)
            char_word = 'word_{}'.format(w)
            
            if char_key not in map_index:
                map_index[char_key] = i
            
            if char_word not in map_index:
                map_index[char_word] = i 
            
            if map_index[char_key] != map_index[char_word]:
                return False
        
        return True
```


## 292. Nim Game

[Problem link](https://leetcode.com/problems/nim-game/)

- My approach

The secret of nim game is: if you can take at most m elements, every time you can make the remained elements to the multiple of `m+1`, then you can must win.

So if the number is already a multiply of `m+1` at the beginning, you should lose.

In this problem, m=3, so we just check if n is a multiple of 4.

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
```

## 295. Find Median from Data Stream  (Official solution)

[Problem link](https://leetcode.com/problems/find-median-from-data-stream/)

- My approach

The key point is how to keep the list sorted whild inserting data.

My idea is using binary insert.

```python
class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.nums = []
        self.even = 1
        self.len = 0
        

    def addNum(self, num: int) -> None:
        if not self.nums:
            self.nums.append(num)
        else:
            l = 0
            r = self.len
            i = (l+r) // 2
            while l < r:
                if self.nums[i] > num:
                    r = i
                else:
                    l = i + 1
                i = (l+r) // 2
            
            self.nums = self.nums[:i] + [num] + self.nums[i:]
                    
        self.even *= -1
        self.len += 1
        

    def findMedian(self) -> float:
        if self.even == 1:
            return (self.nums[self.len//2] + self.nums[self.len//2-1]) /2
        else:
            return float(self.nums[self.len//2])
        


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```

- Official solution

To sort the array dynamicly, `heap` is a good method.

```python
from heapq import *

class MedianFinder:
    def __init__(self):
        self.small = []  # the smaller half of the list, max heap (invert min-heap)
        self.large = []  # the larger half of the list, min heap

    def addNum(self, num):
        # Every time add the smallest number from self.large to self.small
        # or add the larger number from self.small to self.large
        # so the median is (max(self.small)+min(self.large))/2 (even) or min(self.large) (odd)
        if len(self.small) == len(self.large):
            heappush(self.large, -heappushpop(self.small, -num))  # Because python headq can only pop the smallest number, here we change it to opposite number
        else:
            heappush(self.small, -heappushpop(self.large, num))
        # print(self.small, self.large)

    def findMedian(self):
        if len(self.small) == len(self.large):
            return float(self.large[0] - self.small[0]) / 2.0
        else:
            return float(self.large[0])
```

Another way to keep the list sorted is `binary search tree`

In Python, there is a `binsect` module which provides binary search method.

```python
class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.l = []

    def addNum(self, num: int) -> None:
        bisect.insort(self.l, num)  # binsect.insort() can add num to self.l then sort it
        
    def findMedian(self) -> float:
        m,r = divmod(len(self.l), 2)
        if r: return self.l[m]
        elif m: return sum(self.l[m-1:m+1])/2
        return []
```


## 297. Serialize and Deserialize Binary Tree

[Problem link](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

- My approach

My idea is serialize and deserialize the binary tree by using level order traversal.

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ''
        self.t = root
        s = []
        # Level order traversal
        stack = [root]
        while stack:
            temp = []
            for n in stack:
                if n != None:
                    s.append(str(n.val))
                    temp.append(n.left)
                    temp.append(n.right)
                else:
                    s.append('null')
            stack = temp
        
        # Remove all the null at the end
        i = len(s) - 1
        while s[i] == 'null':
            i -= 1
        res = '[' + ','.join(s[:i+1]) + ']'

        return res

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        l = data[1:-1].split(',')
        root = TreeNode(int(l[0]))
        # Reversed level order traversal
        stack = [root]
        i = 1
        while i < len(l):
            temp = []
            for n in stack:
                if not n:
                    continue
                if l[i] != 'null':
                    n.left = TreeNode(int(l[i]))
                else:
                    n.left = None
                i += 1
                if i >= len(l):
                    return root
                
                if l[i] != 'null':
                    n.right = TreeNode(int(l[i]))
                else:
                    n.right = None
                i += 1
                if i >= len(l):
                    return root
                
                temp.append(n.left)
                temp.append(n.right)
            stack = temp
        return root
                

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.deserialize(codec.serialize(root))
```


## 299. Bulls and Cows

[Problem link](https://leetcode.com/problems/bulls-and-cows/)

- My approach

My idea is removing the same numbers with same index firstly(bulls). Then just check if every number in guess is in secret(cows), and pay attention to avoid duplication.

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        s = list(secret)
        g = list(guess)
        
        a = 0  # a is bull
        b = 0  # b is cow
        
        d = {}
        i = 0
        # Remove same numbers with same index, count bulls and save the remain secret in a dictionary as {number: count}
        while i < len(s):
            if s[i] == g[i]:
                a += 1
                s.pop(i)
                g.pop(i)
            else:
                if s[i] in d:
                    d[s[i]] += 1
                else:
                    d[s[i]] = 1
                i += 1
        
        # Count cows
        for i in g:
            if i in d:
                if d[i] > 0:
                    d[i] -= 1
                    b += 1
                    
        return '{}A{}B'.format(a, b)
```

- Other's approach

There is a more clearly method.

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        h = Counter(secret)

        bulls = cows = 0
        for idx, ch in enumerate(guess):
            if ch in h:
                # corresponding characters match
                if ch == secret[idx]:
                    # update the bulls
                    bulls += 1
                    # update the cows 
                    # if all ch characters from secret 
                    # were used up
                    cows -= int(h[ch] <= 0)
                # corresponding characters don't match
                else:
                    # update the cows
                    cows += int(h[ch] > 0)
                # ch character was used
                h[ch] -= 1
                
        return "{}A{}B".format(bulls, cows)
```
