---
layout: article
tags: Leetcode Python
title: Leetcode problems 281-300
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 281 to 300, writing in Python.

<!--more-->

## 282. Expression Add Operators  (Official solution)

[Problem link](https://leetcode.com/problems/expression-add-operators/)

- My approach

My idea is firstly create all the possible expressions for the given num. Then use the method of [Basic Calculator 2](https://leetcode.com/problems/basic-calculator-ii/) 
to calculate the expression.

```python
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        if not num:
            return []
        if num == str(target):
            return [num]

        res = set()
        def helper(idx, exp):
            if idx >= len(num):
                if self.calculate(exp) == target:
                    res.add(exp[:-1])
                return
            # 0 can't be at start of a number
            if num[idx] == '0':
                for e in '+-*':
                    helper(idx+1, exp+num[idx]+e)
            else:
                for i in range(idx, len(num)):
                    for e in '+-*':
                        helper(i+1, exp+num[idx:i+1]+e)
        helper(0, '')
        return res
    
    
    def calculate(self, s: str) -> int:
        num, stack, sig = 0, [], '+'
        for i in s:
            if i in '0123456789':
                num = 10 * num + int(i)
            if i in '+-*/':
                if sig == '+':
                    stack.append(num)
                elif sig == '-':
                    stack.append(-num)
                elif sig == '*':
                    stack.append(stack.pop() * num)
                sig = i
                num = 0 
        return sum(stack)   
```

- Official solution

```python
class Solution:
    def addOperators(self, num: 'str', target: 'int') -> 'List[str]':

        N = len(num)
        answers = []
        def recurse(index, prev_operand, current_operand, value, string):

            # Done processing all the digits in num
            if index == N:

                # If the final value == target expected AND
                # no operand is left unprocessed
                if value == target and current_operand == 0:
                    answers.append("".join(string[1:]))
                return

            # Extending the current operand by one digit
            current_operand = current_operand*10 + int(num[index])
            str_op = str(current_operand)

            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a
            # valid operand. Hence this check
            if current_operand > 0:

                # NO OP recursion
                recurse(index + 1, prev_operand, current_operand, value, string)

            # ADDITION
            string.append('+'); string.append(str_op)
            recurse(index + 1, current_operand, 0, value + current_operand, string)
            string.pop();string.pop()

            # Can subtract or multiply only if there are some previous operands
            if string:

                # SUBTRACTION
                string.append('-'); string.append(str_op)
                recurse(index + 1, -current_operand, 0, value - current_operand, string)
                string.pop();string.pop()

                # MULTIPLICATION
                string.append('*'); string.append(str_op)
                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)
                string.pop();string.pop()
        recurse(0, 0, 0, 0, [])    
        return answers
```


## 283. Move Zeroes

[Problem link](https://leetcode.com/problems/move-zeroes/)

- My approach

My idea is using two pointers. z stands for the index of 0, and p stands for the index of non-zero after z. Each time locating z and p, swap them.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        z = 0
        while z < len(nums) and nums[z] != 0:
            z += 1
        # p must after z 
        p = z
        while p < len(nums) and nums[p] == 0:
            p += 1
            
        while p < len(nums):
            if nums[p] != 0 and nums[z] == 0:
                nums[z], nums[p] = nums[p], nums[z]
            if nums[p] == 0:
                p += 1
            if nums[z] != 0:
                z += 1
```

- Official approach

The method of two pointers can be optimized.

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        p = 0
        z = 0
            
        while p < len(nums):
            if nums[p] != 0:
                nums[z], nums[p] = nums[p], nums[z]
                z += 1
            p += 1
```

Here z stands for the last non-zero number or the first 0. When p is a non-zero number, swap them.


## 284. Peeking Iterator

[Problem link](https://leetcode.com/problems/peeking-iterator/)

- My approach

Firstly save the values of iterator into a list. And set a index to achieve the next and peek operation.

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = []
        while iterator.hasNext():
            self.iterator.append(iterator.next())
        self.idx = 0
        

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        p = self.next()
        self.idx -= 1
        return p
        

    def next(self):
        """
        :rtype: int
        """
        self.idx += 1
        return self.iterator[self.idx-1]
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.idx < len(self.iterator)
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

- Other's approach

The method above needs an extra list to store the values. If we use a varaiable to keep the result of next(), we can achieve the peek() operation. That has only O(1) space complexity.

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = iterator
        self.prev = None
        

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        if not self.prev:
            if self.iterator.hasNext():
                self.prev = self.iterator.next()
        return self.prev
        

    def next(self):
        """
        :rtype: int
        """
        if not self.prev:
            return self.iterator.next()
        else:
            curr = self.prev
            self.prev = None
            return curr
        

    def hasNext(self):
        """
        :rtype: bool
        """
        if self.prev:
            return True
        return self.iterator.hasNext()
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

