---
layout: article
tags: Leetcode Python
title: Leetcode problems 441-460
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 446 to 240, writing in Python.

<!--more-->

## 441. Arranging Coins

[Problem link](https://leetcode.com/problems/arranging-coins/)

- My approach

Start from sqrt(2n), because we can calculate by `x(x-1)/2 = n`, x is close to and smaller than sqrt(2n).

```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        x = int((2*n)**0.5)
        while x > 0:
            if x*(x+1)//2 <= n:
                return x
            x -= 1
        return x
```

## 442. Find All Duplicates in an Array

[Problem link](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

- My approach

Since all the numbers are larger than 1 and smaller than len(nums), we can use the numbers as index. 

For every number n, set nums[n] to negative, and when meet a number that its nums[n] is already negative, means this number has appeared before.

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            n = abs(n)
            if nums[n-1] < 0:
                res.append(n)
            else:
                nums[n-1] *= -1
        return res
```


## 443. String Compression

[Problem link](https://leetcode.com/problems/string-compression/)

- My approach

Add the answers at the tail ot chars, then pop the front elements.

```python
class Solution:
    def compress(self, chars: List[str]) -> int:
        l = len(chars)
        i = 0
        while i < l:
            chars.append(chars[i])
            if i+1 < l and chars[i] == chars[i+1]:
                start = i
                i += 1
                while i < l and chars[i] == chars[start]:
                    i += 1
                length = i - start
                chars += list(str(length))
            else:
                i += 1
        for _ in range(l):
            chars.pop(0)
        return len(chars)
```


## 445. Add Two Numbers II

[Problem link](https://leetcode.com/problems/add-two-numbers-ii/)

- My approach

Firstly converse the two linked lists to integer, then add the two integers and converse the sum to linked list.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        n1 = 0
        while l1:
            n1 = n1*10 + l1.val
            l1 = l1.next
        n2 = 0
        while l2:
            n2 = n2*10 + l2.val
            l2 = l2.next
        
        n = n1 + n2
        if n == 0:
            return ListNode(0)
        res = None
        while n > 0:
            curr = n % 10
            n = n // 10
            curr_node = ListNode(curr)
            curr_node.next = res
            res = curr_node
        return res
```


## 446. Arithmetic Slices II - Subsequence  (Dynamic programming)

[Problem link](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/)

- My approach

Use dynamic programming, and count[i][j] stands for the count of arithmetic elices end by i and their commom intervals are j.

For more explanations, see [official solution](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/solution/).

```python
class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        res = 0
        count = collections.defaultdict(dict)
        for i in range(len(A)):
            for j in range(i):
                interval = A[i] - A[j]
                _sum = 0
                if interval in count[j]:
                    _sum = count[j][interval]
                origin = 0
                if interval in count[i]:
                    origin = count[i][interval]
                count[i][interval] = origin + _sum + 1  # modify current count
                res += _sum
        return res
```
