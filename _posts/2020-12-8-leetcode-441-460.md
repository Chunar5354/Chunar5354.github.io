---
layout: article
tags: Leetcode Python
title: Leetcode problems 441-460
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 446 to 240, writing in Python.

<!--more-->

## 441. Arranging Coins

[Problem link](https://leetcode.com/problems/arranging-coins/)

- My approach

Start from sqrt(2n), because we can calculate by `x(x-1)/2 = n`, x is close to and smaller than sqrt(2n).

```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        x = int((2*n)**0.5)
        while x > 0:
            if x*(x+1)//2 <= n:
                return x
            x -= 1
        return x
```

## 442. Find All Duplicates in an Array

[Problem link](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

- My approach

Since all the numbers are larger than 1 and smaller than len(nums), we can use the numbers as index. 

For every number n, set nums[n] to negative, and when meet a number that its nums[n] is already negative, means this number has appeared before.

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            n = abs(n)
            if nums[n-1] < 0:
                res.append(n)
            else:
                nums[n-1] *= -1
        return res
```


## 443. String Compression

[Problem link](https://leetcode.com/problems/string-compression/)

- My approach

Add the answers at the tail ot chars, then pop the front elements.

```python
class Solution:
    def compress(self, chars: List[str]) -> int:
        l = len(chars)
        i = 0
        while i < l:
            chars.append(chars[i])
            if i+1 < l and chars[i] == chars[i+1]:
                start = i
                i += 1
                while i < l and chars[i] == chars[start]:
                    i += 1
                length = i - start
                chars += list(str(length))
            else:
                i += 1
        for _ in range(l):
            chars.pop(0)
        return len(chars)
```


## 445. Add Two Numbers II

[Problem link](https://leetcode.com/problems/add-two-numbers-ii/)

- My approach

Firstly converse the two linked lists to integer, then add the two integers and converse the sum to linked list.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        n1 = 0
        while l1:
            n1 = n1*10 + l1.val
            l1 = l1.next
        n2 = 0
        while l2:
            n2 = n2*10 + l2.val
            l2 = l2.next
        
        n = n1 + n2
        if n == 0:
            return ListNode(0)
        res = None
        while n > 0:
            curr = n % 10
            n = n // 10
            curr_node = ListNode(curr)
            curr_node.next = res
            res = curr_node
        return res
```


## 446. Arithmetic Slices II - Subsequence  (Dynamic programming)

[Problem link](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/)

- My approach

Use dynamic programming, and count[i][j] stands for the count of arithmetic elices end by i and their commom intervals are j.

For more explanations, see [official solution](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/solution/).

```python
class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        res = 0
        count = collections.defaultdict(dict)
        for i in range(len(A)):
            for j in range(i):
                interval = A[i] - A[j]
                _sum = 0
                if interval in count[j]:
                    _sum = count[j][interval]
                origin = 0
                if interval in count[i]:
                    origin = count[i][interval]
                count[i][interval] = origin + _sum + 1  # modify current count
                res += _sum
        return res
```


## 447. Number of Boomerangs

[Problem link](https://leetcode.com/problems/number-of-boomerangs/)

- My approach

The key point is for every point finding out how many other points have the same distance from it. Use a two level dictionary to find this.

And if the number of same distance points of current point is n, to construct boomerang, we need to pick two points, and the order is matter, so the count of current boomerangs 
equals to `n*(n-1)`.

```python
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        dic = collections.defaultdict(dict)
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                length = (points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2
                if length in dic[i]:
                    dic[i][length] += 1
                else:
                    dic[i][length] = 1
                if length in dic[j]:
                    dic[j][length] += 1
                else:
                    dic[j][length] = 1
        res = 0
        for k1 in dic:
            for k2 in dic[k1]:
                curr = dic[k1][k2]
                if curr >= 2:
                    res += (curr-1)*curr
        return res
```


## 448. Find All Numbers Disappeared in an Array

[Problem link](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

- My approach

1. Since 1 <= nums[i] <= n, we can modify nums with nums[i] as their indexes. For every n in nums, mutiply -1 if nums[n] is positive, finally the positions with positive numbers 
are the missing numbers.

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        nums = [0] + nums
        for n in nums:
            n = abs(n)
            if nums[n] > 0:
                nums[n] *= (-1)
        
        res = []
        for i in range(len(nums)):
            if nums[i] > 0:
                res.append(i)
        return res
```

2. Use set

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        whole = set(range(1, len(nums)+1))
        n = set(nums)
        return list(whole-n)
```

## 449. Serialize and Deserialize BST

[Problem link](https://leetcode.com/problems/serialize-and-deserialize-bst/)

- My approach

Use level traversal, ans when serialize the tree, use "X" to stand for None.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        if not root:
            return ''
        stack = [root]
        res = ''
        while stack:
            curr_stack = []
            for n in stack:
                if not n:
                    res += 'X,'  # Use "," to sparate the values
                else:
                    res += str(n.val) + ','
                    curr_stack.append(n.left)
                    curr_stack.append(n.right)
            stack = curr_stack
        return res

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        if not data:
            return None
        data = data.split(',')
        root = TreeNode(int(data[0]))
        stack = [root]
        i = 1
        while stack and i < len(data):
            curr_stack = []
            for n in stack:
                if data[i] != 'X':
                    n.left = TreeNode(int(data[i]))
                    curr_stack.append(n.left)
                i += 1
                if i >= len(data):
                    break
                if data[i] != 'X':
                    n.right = TreeNode(int(data[i]))
                    curr_stack.append(n.right)
                i += 1
                if i >= len(data):
                    break
            stack = curr_stack
        return root

# Your Codec object will be instantiated and called as such:
# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
```


## 450. Delete Node in a BST

[Problem link](https://leetcode.com/problems/delete-node-in-a-bst/)

- My approach

For a binary search tree, when delete a node, means replace its value with its predecessor value(the most right node of left child), or the successor value(the most left node 
of right child). Go on do this replacement when get to leaf node, and just delete the leaf node.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None
        if root.val == key and not root.left and not root.right:
            return None
        n = root
        to_delete = n
        # Firstly find the node to delete
        while n.val != key:
            if n.val > key:
                if n.left and n.left.val == key:
                    to_delete = n.left
                    break
                n = n.left
            elif n.val < key:
                if n.right and n.right.val == key:
                    to_delete = n.right
                    break
                n = n.right
            if not n:
                return root
        
        def dele(to_delete, father):
            # for leaf nodes
            if not to_delete.left and not to_delete.right:
                if father.left and to_delete.val == father.left.val:
                    father.left = None
                else:
                    father.right = None
                return
            
            # Change the target node with the most left node of right child 
            # or most right node of left child
            # Then if the change node is not a leaf node, go on delete
            if not to_delete.left:
                to_change = to_delete.right
                father = to_delete
                while to_change.left:
                    father = to_change
                    to_change = to_change.left
                to_delete.val = to_change.val
                dele(to_change, father)
            else:
                to_change = to_delete.left
                father = to_delete
                while to_change.right:
                    father = to_change
                    to_change = to_change.right
                to_delete.val = to_change.val
                dele(to_change, father)
        
        dele(to_delete, n)
        return root
```


## 451. Sort Characters By Frequency

[Problem link](https://leetcode.com/problems/sort-characters-by-frequency/)

- My approach

Sort the characters by the count.

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        dic = {}
        for c in s:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        count = {}
        for k in dic:
            if dic[k] in count:
                count[dic[k]].append(k)
            else:
                count[dic[k]] = [k]
        
        counts = list(count.keys())
        counts.sort()
        res = ''
        for n in counts:
            for c in count[n]:
                res = n*c + res
        return res
```


In python, we can use `lambda` in sort.

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        dic = {}
        for c in s:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        res = ""
        count = list(dic.keys())
        count.sort(key = lambda x: -dic[x])
        for c in count:
            res += c * dic[c]
        return res
```

## 452. Minimum Number of Arrows to Burst Balloons

[Problem link](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)

- My approach

If one arrow can burst two balloons, means the two balloons have overlap. And if we sort the balloons with the start point, the overlap can be described as that the end point 
of the second balloon is smaller than the first balloon.

For more balloons, we can keep a varaible stands for the right edge, when a new balloon comes, if its start point is smaller than the right edge, it can be burst by the same 
arrow with the group before. Then modify the right edge with the minimum end point(to avoid missing the balloons in middle)

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points.sort()
        right = points[0][1]
        i = 1
        arrows = 1
        while i < len(points):
            if points[i][0] <= right:
                # current balloon can be burst with the arrow before, modify the right edge
                right = min(right, points[i][1])
            else:
                # current balloon need a new arrow to burst, and the new right edge is the end point of current balloon
                arrows += 1
                right = points[i][1]
            i += 1
        return arrows
```

## 453. Minimum Moves to Equal Array Elements

[Problem link](https://leetcode.com/problems/minimum-moves-to-equal-array-elements/)

- My approach

Mathimatical method.

```python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums)-min(nums)*len(nums)
```


## 454. 4Sum II  (Other's approach)

[Problem link](https://leetcode.com/problems/4sum-ii/)

- Other's approach

Combinate two arrays as a group with the formate `{the_sum_of_two: count}`. Then calculate the four_sum by the two groups.

```python
from collections import defaultdict
class Solution: 
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        AB, CD = defaultdict(int), defaultdict(int)
        for i in range(len(A)):
            for j in range(len(B)):
                AB[A[i] + B[j]] += 1
        
        for k in range(len(C)):
            for l in range(len(D)):
                CD[C[k] + D[l]] += 1
        
        total = 0
        for ab in AB:
            total += CD[-ab] * AB[ab]
        return total
```


## 455. Assign Cookies

[Problem link](https://leetcode.com/problems/assign-cookies/)

- My approach

Sort and traversal s and g and find until s[j] >= g[i].

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i = j = 0
        res = 0
        while i < len(g) and j < len(s):
            while s[j] < g[i]:
                j += 1
                if j >= len(s):
                    return res
            res += 1
            i += 1
            j += 1
                
        return res
```

## 456. 132 Pattern  (Official solution)

[Problem link](https://leetcode.com/problems/132-pattern/)

- Official approach

O(n) solution.

Firstly create an array minBefore that minBefore[i] stands for the minimum number befoer i.

Then traverse from right with stack, and we should keep the numbers in stack larger than minBefore[j], so if the number in stack is smaller than nums[j], we find a 132 patterm.

```python
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        minBefore = [nums[0]] * len(nums)
        for i in range(1, len(nums)):
            minBefore[i] = min(nums[i], minBefore[i-1])
        stack = []
        for j in range(len(nums)-1, -1, -1):
            if nums[j] > minBefore[j]:
                while stack and stack[-1] <= minBefore[j]:  # delete the numbers smaller than the minimum of left
                    stack.pop()
                if stack and stack[-1] < nums[j]:
                    return True
                stack.append(nums[j])
                
        return False
```
