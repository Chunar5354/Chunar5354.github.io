---
layout: article
tags: Leetcode Python
title: Leetcode problems 441-460
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 446 to 240, writing in Python.

<!--more-->

## 441. Arranging Coins

[Problem link](https://leetcode.com/problems/arranging-coins/)

- My approach

Start from sqrt(2n), because we can calculate by `x(x-1)/2 = n`, x is close to and smaller than sqrt(2n).

```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        x = int((2*n)**0.5)
        while x > 0:
            if x*(x+1)//2 <= n:
                return x
            x -= 1
        return x
```

## 442. Find All Duplicates in an Array

[Problem link](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

- My approach

Since all the numbers are larger than 1 and smaller than len(nums), we can use the numbers as index. 

For every number n, set nums[n] to negative, and when meet a number that its nums[n] is already negative, means this number has appeared before.

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            n = abs(n)
            if nums[n-1] < 0:
                res.append(n)
            else:
                nums[n-1] *= -1
        return res
```


## 443. String Compression

[Problem link](https://leetcode.com/problems/string-compression/)

- My approach

Add the answers at the tail ot chars, then pop the front elements.

```python
class Solution:
    def compress(self, chars: List[str]) -> int:
        l = len(chars)
        i = 0
        while i < l:
            chars.append(chars[i])
            if i+1 < l and chars[i] == chars[i+1]:
                start = i
                i += 1
                while i < l and chars[i] == chars[start]:
                    i += 1
                length = i - start
                chars += list(str(length))
            else:
                i += 1
        for _ in range(l):
            chars.pop(0)
        return len(chars)
```


## 445. Add Two Numbers II

[Problem link](https://leetcode.com/problems/add-two-numbers-ii/)

- My approach

Firstly converse the two linked lists to integer, then add the two integers and converse the sum to linked list.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        n1 = 0
        while l1:
            n1 = n1*10 + l1.val
            l1 = l1.next
        n2 = 0
        while l2:
            n2 = n2*10 + l2.val
            l2 = l2.next
        
        n = n1 + n2
        if n == 0:
            return ListNode(0)
        res = None
        while n > 0:
            curr = n % 10
            n = n // 10
            curr_node = ListNode(curr)
            curr_node.next = res
            res = curr_node
        return res
```


## 446. Arithmetic Slices II - Subsequence  (Dynamic programming)

[Problem link](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/)

- My approach

Use dynamic programming, and count[i][j] stands for the count of arithmetic elices end by i and their commom intervals are j.

For more explanations, see [official solution](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/solution/).

```python
class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        res = 0
        count = collections.defaultdict(dict)
        for i in range(len(A)):
            for j in range(i):
                interval = A[i] - A[j]
                _sum = 0
                if interval in count[j]:
                    _sum = count[j][interval]
                origin = 0
                if interval in count[i]:
                    origin = count[i][interval]
                count[i][interval] = origin + _sum + 1  # modify current count
                res += _sum
        return res
```


## 447. Number of Boomerangs

[Problem link](https://leetcode.com/problems/number-of-boomerangs/)

- My approach

The key point is for every point finding out how many other points have the same distance from it. Use a two level dictionary to find this.

And if the number of same distance points of current point is n, to construct boomerang, we need to pick two points, and the order is matter, so the count of current boomerangs 
equals to `n*(n-1)`.

```python
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        dic = collections.defaultdict(dict)
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                length = (points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2
                if length in dic[i]:
                    dic[i][length] += 1
                else:
                    dic[i][length] = 1
                if length in dic[j]:
                    dic[j][length] += 1
                else:
                    dic[j][length] = 1
        res = 0
        for k1 in dic:
            for k2 in dic[k1]:
                curr = dic[k1][k2]
                if curr >= 2:
                    res += (curr-1)*curr
        return res
```


## 448. Find All Numbers Disappeared in an Array

[Problem link](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

- My approach

1. Since 1 <= nums[i] <= n, we can modify nums with nums[i] as their indexes. For every n in nums, mutiply -1 if nums[n] is positive, finally the positions with positive numbers 
are the missing numbers.

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        nums = [0] + nums
        for n in nums:
            n = abs(n)
            if nums[n] > 0:
                nums[n] *= (-1)
        
        res = []
        for i in range(len(nums)):
            if nums[i] > 0:
                res.append(i)
        return res
```

2. Use set

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        whole = set(range(1, len(nums)+1))
        n = set(nums)
        return list(whole-n)
```

## 449. Serialize and Deserialize BST

[Problem link](https://leetcode.com/problems/serialize-and-deserialize-bst/)

- My approach

Use level traversal, ans when serialize the tree, use "X" to stand for None.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        if not root:
            return ''
        stack = [root]
        res = ''
        while stack:
            curr_stack = []
            for n in stack:
                if not n:
                    res += 'X,'  # Use "," to sparate the values
                else:
                    res += str(n.val) + ','
                    curr_stack.append(n.left)
                    curr_stack.append(n.right)
            stack = curr_stack
        return res

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        if not data:
            return None
        data = data.split(',')
        root = TreeNode(int(data[0]))
        stack = [root]
        i = 1
        while stack and i < len(data):
            curr_stack = []
            for n in stack:
                if data[i] != 'X':
                    n.left = TreeNode(int(data[i]))
                    curr_stack.append(n.left)
                i += 1
                if i >= len(data):
                    break
                if data[i] != 'X':
                    n.right = TreeNode(int(data[i]))
                    curr_stack.append(n.right)
                i += 1
                if i >= len(data):
                    break
            stack = curr_stack
        return root

# Your Codec object will be instantiated and called as such:
# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
```


## 450. Delete Node in a BST

[Problem link](https://leetcode.com/problems/delete-node-in-a-bst/)

- My approach

For a binary search tree, when delete a node, means replace its value with its predecessor value(the most right node of left child), or the successor value(the most left node 
of right child). Go on do this replacement when get to leaf node, and just delete the leaf node.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None
        if root.val == key and not root.left and not root.right:
            return None
        n = root
        to_delete = n
        # Firstly find the node to delete
        while n.val != key:
            if n.val > key:
                if n.left and n.left.val == key:
                    to_delete = n.left
                    break
                n = n.left
            elif n.val < key:
                if n.right and n.right.val == key:
                    to_delete = n.right
                    break
                n = n.right
            if not n:
                return root
        
        def dele(to_delete, father):
            # for leaf nodes
            if not to_delete.left and not to_delete.right:
                if father.left and to_delete.val == father.left.val:
                    father.left = None
                else:
                    father.right = None
                return
            
            # Change the target node with the most left node of right child 
            # or most right node of left child
            # Then if the change node is not a leaf node, go on delete
            if not to_delete.left:
                to_change = to_delete.right
                father = to_delete
                while to_change.left:
                    father = to_change
                    to_change = to_change.left
                to_delete.val = to_change.val
                dele(to_change, father)
            else:
                to_change = to_delete.left
                father = to_delete
                while to_change.right:
                    father = to_change
                    to_change = to_change.right
                to_delete.val = to_change.val
                dele(to_change, father)
        
        dele(to_delete, n)
        return root
```


## 451. Sort Characters By Frequency

[Problem link](https://leetcode.com/problems/sort-characters-by-frequency/)

- My approach

Sort the characters by the count.

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        dic = {}
        for c in s:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        count = {}
        for k in dic:
            if dic[k] in count:
                count[dic[k]].append(k)
            else:
                count[dic[k]] = [k]
        
        counts = list(count.keys())
        counts.sort()
        res = ''
        for n in counts:
            for c in count[n]:
                res = n*c + res
        return res
```


In python, we can use `lambda` in sort.

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        dic = {}
        for c in s:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        res = ""
        count = list(dic.keys())
        count.sort(key = lambda x: -dic[x])
        for c in count:
            res += c * dic[c]
        return res
```

## 452. Minimum Number of Arrows to Burst Balloons

[Problem link](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)

- My approach

If one arrow can burst two balloons, means the two balloons have overlap. And if we sort the balloons with the start point, the overlap can be described as that the end point 
of the second balloon is smaller than the first balloon.

For more balloons, we can keep a varaible stands for the right edge, when a new balloon comes, if its start point is smaller than the right edge, it can be burst by the same 
arrow with the group before. Then modify the right edge with the minimum end point(to avoid missing the balloons in middle)

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points.sort()
        right = points[0][1]
        i = 1
        arrows = 1
        while i < len(points):
            if points[i][0] <= right:
                # current balloon can be burst with the arrow before, modify the right edge
                right = min(right, points[i][1])
            else:
                # current balloon need a new arrow to burst, and the new right edge is the end point of current balloon
                arrows += 1
                right = points[i][1]
            i += 1
        return arrows
```

## 453. Minimum Moves to Equal Array Elements

[Problem link](https://leetcode.com/problems/minimum-moves-to-equal-array-elements/)

- My approach

Mathimatical method.

```python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        return sum(nums)-min(nums)*len(nums)
```


## 454. 4Sum II  (Other's approach)

[Problem link](https://leetcode.com/problems/4sum-ii/)

- Other's approach

Combinate two arrays as a group with the formate `{the_sum_of_two: count}`. Then calculate the four_sum by the two groups.

```python
from collections import defaultdict
class Solution: 
    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:
        AB, CD = defaultdict(int), defaultdict(int)
        for i in range(len(A)):
            for j in range(len(B)):
                AB[A[i] + B[j]] += 1
        
        for k in range(len(C)):
            for l in range(len(D)):
                CD[C[k] + D[l]] += 1
        
        total = 0
        for ab in AB:
            total += CD[-ab] * AB[ab]
        return total
```


## 455. Assign Cookies

[Problem link](https://leetcode.com/problems/assign-cookies/)

- My approach

Sort and traversal s and g and find until s[j] >= g[i].

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        i = j = 0
        res = 0
        while i < len(g) and j < len(s):
            while s[j] < g[i]:
                j += 1
                if j >= len(s):
                    return res
            res += 1
            i += 1
            j += 1
                
        return res
```

## 456. 132 Pattern  (Official solution)

[Problem link](https://leetcode.com/problems/132-pattern/)

- Official approach

O(n) solution.

Firstly create an array minBefore that minBefore[i] stands for the minimum number befoer i.

Then traverse from right with stack, and we should keep the numbers in stack larger than minBefore[j], so if the number in stack is smaller than nums[j], we find a 132 patterm.

```python
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        minBefore = [nums[0]] * len(nums)
        for i in range(1, len(nums)):
            minBefore[i] = min(nums[i], minBefore[i-1])
        stack = []
        for j in range(len(nums)-1, -1, -1):
            if nums[j] > minBefore[j]:
                while stack and stack[-1] <= minBefore[j]:  # delete the numbers smaller than the minimum of left
                    stack.pop()
                if stack and stack[-1] < nums[j]:
                    return True
                stack.append(nums[j])
                
        return False
```


## 457. Circular Array Loop

[Problem link](https://leetcode.com/problems/circular-array-loop/)

- My approach

There are two points for a loop:

1. The numbers must be all positive or negative

2. Ther can't be only one number's loop(when a number equals to the length of nums)

Traverse nums with two memories.

```python
class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
        l = len(nums)
        mem = set()  # mem is to avoid repeated visit
        for i in range(l):
            if i in mem:
                continue
            seen = set()  # seen is to check if there is a loop
            direction = 1 if nums[i] > 0 else -1
            while True:
                if abs(nums[i]) == l or nums[i] % l == 0:  # loop to itself
                      break
                if i in seen:  # there is a loop
                    return True
                seen.add(i)
                mem.add(i)
                i = (i+nums[i]) % l  # next number
                if nums[i] * direction < 0:  # must be one direction
                    break
        return False
```


## 458. Poor Pigs  (Other's approach)

[Problem link](https://leetcode.com/problems/poor-pigs/)

- Other's approach

Use mathematical method, see the number of pigs as bit, and test time as group. The buskets should less than `(times+1)^pigs`.

For more explanation, please see [here](https://leetcode.com/problems/poor-pigs/discuss/935112/Python-Math-solution-detailed-expanations).

```python
class Solution:
    def poorPigs(self, buckets, minutesToDie, minutesToTest):
        return ceil(log(buckets)/log(minutesToTest//minutesToDie + 1))
        # use swap formula : loga(b) = logc(b)/logc(a)
```


## 459. Repeated Substring Pattern

[Problem link](https://leetcode.com/problems/repeated-substring-pattern/)

- My approach

Traverse s, snd for every index i, check if all the s[i:i+i]  == s[:i].

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        l = len(s)
        for i in range(l):
            if i == l-1:
                return False
            if l % (i+1) == 0:
                valid = True
                for j in range(i+1, l, i+1):
                    if s[j:j+i+1] != s[:i+1]:
                        valid = False
                        break
                if valid:
                    return True
        return False
```

- Othre's approach

If a string contains repested pattern, when we cut the first character and last character and connect the two new substrings(make it as a circle), the original 
string should be contained in the new string `s[1:] + s[:-1]`.

```python
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        return s in s[1:] + s[:-1]
```


## 460. LFU Cache  (Other's approach, to be continued)

[Problem link](https://leetcode.com/problems/lfu-cache/)

- My approach

Use two dictionaries to store the frequency, `k_f{key: frequenvy}` and `f_k{frequency: {key1, key2 ...}`, and a list `lru`, when a key is recelently used, put it at the end of lru.

When putting keys, check if the data is larger than capacity, if yes, find the smallest frequency in f_k. If there are more than one keys in f_k[min_freq], find the first key 
in lru, delete it. Then add the frequency of current key, and put current key at the end of lru.

When getting keys, ckeck if the key is in data, then add the frequency and modify lru.

```python
class LFUCache:

    def __init__(self, capacity: int):
        self.data = {}
        self.cap = capacity
        self.k_f = collections.defaultdict(int)
        self.f_k = collections.defaultdict(set)
        self.lru = []
        

    def get(self, key: int) -> int:
        if key in self.data:
            if key in self.k_f:
                last_frep = self.k_f[key]
                self.f_k[last_frep].remove(key)
                if not self.f_k[last_frep]:
                    self.f_k.pop(last_frep)
                for i in range(len(self.lru)):
                    if self.lru[i] == key:
                        self.lru.pop(i)
                        break
            self.k_f[key] += 1
            self.f_k[self.k_f[key]].add(key)
            self.lru.append(key)
        
        if key in self.data:
            return self.data[key]
        return -1
        

    def put(self, key: int, value: int) -> None:
        if self.cap == 0:
            return
        self.data[key] = value
        
        if len(self.data) > self.cap:
            min_freq = min(self.f_k.keys())
            for i in range(len(self.lru)):
                k = self.lru[i]
                
                if k in self.f_k[min_freq]:
                    self.f_k[min_freq].remove(k)
                    if not self.f_k[min_freq]:
                        self.f_k.pop(min_freq)
                    self.k_f.pop(k)
                    self.data.pop(k)
                    self.lru.pop(i)
                    break
        
        if key in self.k_f:
            last_frep = self.k_f[key]
            self.f_k[last_frep].remove(key)
            for i in range(len(self.lru)):
                if self.lru[i] == key:
                    self.lru.pop(i)
                    break
        self.k_f[key] += 1
        self.f_k[self.k_f[key]].add(key)
        self.lru.append(key)
        


# Your LFUCache object will be instantiated and called as such:
# obj = LFUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

All the operations in this solution use original data structure, so it runs very slowly.


- Other's approach

```python
class Node:
    def __init__(self, value, freq):
        self.value = value
        self.freq = freq
        
class LFUCache:

    def __init__(self, cap: int):
        self.freq = defaultdict(OrderedDict) 
        self.d = {}
        self.minfreq = -1
        self.cap = cap

    def get(self, key: int) -> int:
        if key not in self.d:
            return -1
        n = self.d[key]
        od = self.freq[n.freq]
        del od[key]
        if not od and self.minfreq == n.freq:
            self.minfreq += 1
        n.freq += 1
        od = self.freq[n.freq]
        od[key] = n
        return n.value

    def put(self, key: int, value: int) -> None:
        if self.get(key) != -1:
            self.d[key].value = value
            return
        if self.cap == 0:
            return
        if len(self.d) == self.cap:
            od = self.freq[self.minfreq]
            k, v = od.popitem(last=False)
            del self.d[k]
        n = Node(value, 1)
        self.d[key] = n
        self.freq[1][key] = n
        self.minfreq = 1
```

