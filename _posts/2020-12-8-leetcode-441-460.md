---
layout: article
tags: Leetcode Python
title: Leetcode problems 441-460
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 446 to 240, writing in Python.

<!--more-->

## 441. Arranging Coins

[Problem link](https://leetcode.com/problems/arranging-coins/)

- My approach

Start from sqrt(2n), because we can calculate by `x(x-1)/2 = n`, x is close to and smaller than sqrt(2n).

```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        x = int((2*n)**0.5)
        while x > 0:
            if x*(x+1)//2 <= n:
                return x
            x -= 1
        return x
```

## 442. Find All Duplicates in an Array

[Problem link](https://leetcode.com/problems/find-all-duplicates-in-an-array/)

- My approach

Since all the numbers are larger than 1 and smaller than len(nums), we can use the numbers as index. 

For every number n, set nums[n] to negative, and when meet a number that its nums[n] is already negative, means this number has appeared before.

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            n = abs(n)
            if nums[n-1] < 0:
                res.append(n)
            else:
                nums[n-1] *= -1
        return res
```


## 443. String Compression

[Problem link](https://leetcode.com/problems/string-compression/)

- My approach

Add the answers at the tail ot chars, then pop the front elements.

```python
class Solution:
    def compress(self, chars: List[str]) -> int:
        l = len(chars)
        i = 0
        while i < l:
            chars.append(chars[i])
            if i+1 < l and chars[i] == chars[i+1]:
                start = i
                i += 1
                while i < l and chars[i] == chars[start]:
                    i += 1
                length = i - start
                chars += list(str(length))
            else:
                i += 1
        for _ in range(l):
            chars.pop(0)
        return len(chars)
```


## 445. Add Two Numbers II

[Problem link](https://leetcode.com/problems/add-two-numbers-ii/)

- My approach

Firstly converse the two linked lists to integer, then add the two integers and converse the sum to linked list.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        n1 = 0
        while l1:
            n1 = n1*10 + l1.val
            l1 = l1.next
        n2 = 0
        while l2:
            n2 = n2*10 + l2.val
            l2 = l2.next
        
        n = n1 + n2
        if n == 0:
            return ListNode(0)
        res = None
        while n > 0:
            curr = n % 10
            n = n // 10
            curr_node = ListNode(curr)
            curr_node.next = res
            res = curr_node
        return res
```


## 446. Arithmetic Slices II - Subsequence  (Dynamic programming)

[Problem link](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/)

- My approach

Use dynamic programming, and count[i][j] stands for the count of arithmetic elices end by i and their commom intervals are j.

For more explanations, see [official solution](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/solution/).

```python
class Solution:
    def numberOfArithmeticSlices(self, A: List[int]) -> int:
        res = 0
        count = collections.defaultdict(dict)
        for i in range(len(A)):
            for j in range(i):
                interval = A[i] - A[j]
                _sum = 0
                if interval in count[j]:
                    _sum = count[j][interval]
                origin = 0
                if interval in count[i]:
                    origin = count[i][interval]
                count[i][interval] = origin + _sum + 1  # modify current count
                res += _sum
        return res
```


## 447. Number of Boomerangs

[Problem link](https://leetcode.com/problems/number-of-boomerangs/)

- My approach

The key point is for every point finding out how many other points have the same distance from it. Use a two level dictionary to find this.

And if the number of same distance points of current point is n, to construct boomerang, we need to pick two points, and the order is matter, so the count of current boomerangs 
equals to `n*(n-1)`.

```python
class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        dic = collections.defaultdict(dict)
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                length = (points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2
                if length in dic[i]:
                    dic[i][length] += 1
                else:
                    dic[i][length] = 1
                if length in dic[j]:
                    dic[j][length] += 1
                else:
                    dic[j][length] = 1
        res = 0
        for k1 in dic:
            for k2 in dic[k1]:
                curr = dic[k1][k2]
                if curr >= 2:
                    res += (curr-1)*curr
        return res
```


## 448. Find All Numbers Disappeared in an Array

[Problem link](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)

- My approach

1. Since 1 <= nums[i] <= n, we can modify nums with nums[i] as their indexes. For every n in nums, mutiply -1 if nums[n] is positive, finally the positions with positive numbers 
are the missing numbers.

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        nums = [0] + nums
        for n in nums:
            n = abs(n)
            if nums[n] > 0:
                nums[n] *= (-1)
        
        res = []
        for i in range(len(nums)):
            if nums[i] > 0:
                res.append(i)
        return res
```

2. Use set

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        whole = set(range(1, len(nums)+1))
        n = set(nums)
        return list(whole-n)
```

## 449. Serialize and Deserialize BST

[Problem link](https://leetcode.com/problems/serialize-and-deserialize-bst/)

- My approach

Use level traversal, ans when serialize the tree, use "X" to stand for None.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        if not root:
            return ''
        stack = [root]
        res = ''
        while stack:
            curr_stack = []
            for n in stack:
                if not n:
                    res += 'X,'  # Use "," to sparate the values
                else:
                    res += str(n.val) + ','
                    curr_stack.append(n.left)
                    curr_stack.append(n.right)
            stack = curr_stack
        return res

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        if not data:
            return None
        data = data.split(',')
        root = TreeNode(int(data[0]))
        stack = [root]
        i = 1
        while stack and i < len(data):
            curr_stack = []
            for n in stack:
                if data[i] != 'X':
                    n.left = TreeNode(int(data[i]))
                    curr_stack.append(n.left)
                i += 1
                if i >= len(data):
                    break
                if data[i] != 'X':
                    n.right = TreeNode(int(data[i]))
                    curr_stack.append(n.right)
                i += 1
                if i >= len(data):
                    break
            stack = curr_stack
        return root

# Your Codec object will be instantiated and called as such:
# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
```

