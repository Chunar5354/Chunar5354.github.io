---
layout: article
tags: Leetcode Python
title: Leetcode problems 401-420
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 401 to 420, writing in Python.

<!--more-->

## 401. Binary Watch

[Problem link](https://leetcode.com/problems/binary-watch/)

- My approach

In my solution, the key idea is to find the m combination from a n-length array, here I use recursing.

```python
class Solution:
    def readBinaryWatch(self, num: int) -> List[str]:
        h = [1, 2, 4, 8]
        m = [1, 2, 4, 8, 16, 32]
        
        def helper(n, l):  # get n combination from l
            if n == 0:
                return [0]
            if n == 1:
                return l
            ans = []
            for i in range(len(l)):
                ans += [l[i]+j for j in helper(n-1, l[i+1:])]
            return ans
        
                        
        res = []
        for i in range(num+1):
            # i stands for there are i LEDs of hour are on, so there can be num-i LEDs of minute are on
            # h
            hours = helper(i, h)
            # m
            minutes = helper(num-i, m)
            # get all the possible combinations of hours and minutes, then compose them
            for hh in hours:
                if hh > 11:
                    continue
                for mm in minutes:
                    if mm > 59:
                        continue
                    if mm < 10:
                        res.append(str(hh) + ':0' + str(mm))
                    else:
                        res.append(str(hh) + ':' + str(mm))
        return res      
```


- Other's approach

For this problem, each LED stands for a number of `2^n`, so we can check for the bits of the numbers, a bit '1' can represent a lighting LED.

```python
class Solution:
    def readBinaryWatch(self, num: int) -> List[str]:
        res = []
        for i in range(0, 12):
            for j in range(0, 60):
                if  (bin(i)+bin(j)).count('1') == num:
                    res.append('%d:%02d'%(i,j))  # %02d to format the length
        return res
```


## 402. Remove K Digits  (Stack)

[Problem link](https://leetcode.com/problems/remove-k-digits/)

- My approach

Traverse from left to right, when meet a number that num[i] > num[i+1], pop num[i], do this for k times.

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        if len(num) == k:
            return '0'
        num = num + '0'
        for _ in range(k):
            if int(num) == 0:
                return '0'
            for i in range(len(num)-1):
                if num[i] > num[i+1]:
                    num = num[:i] + num[i+1:]
                    break
        n = int(num[:-1])
        return str(n)
```

The solution above has O(k*n) time complexity.

- Other's approach

This is a simplified solution by using stack. Save the numbers in stack from left to right, and when meet a number that is less than stack[-1], 
pop all the larger numbers at the end of stack. And do this for k times.

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        
        for n in num:
            while stack and stack[-1] > n and k > 0:
                k -= 1
                stack.pop()
            stack.append(n)
        
        while k > 0:
            stack.pop()
            k -= 1
        
        if not stack:
            return '0'
        
        return str(int(''.join(stack)))
```


## 403. Frog Jump  (Dynamic programming)

[Problem link](https://leetcode.com/problems/frog-jump/)

- My approach

My own recursing solution was time limited exceeded.

- Other's approach

Use dynamic programming, save the structure as `{stone:(the steps taked to jump to this stone)}`.

Then traverse the given stones, for each stone, the next stone it can reach will be in `stone + (step-1, step, step+1)`.

After dealing with all the stones, if can jump to the final stone, there must be some values in the dic[final_stone].

```python
class Solution:
    def canCross(self, stones: List[int]) -> bool:
        dic = {i:set() for i in stones}
        dic[0] = {0}
        
        for stone in stones:
            for step in dic[stone]:
                for jump in (step-1, step, step+1):
                    nextStone = stone + jump  # The next stone can be reached
                    if nextStone != stone and nextStone in dic:
                        dic[nextStone].add(jump)
        
        return len(dic[stones[-1]]) > 0
```


## 404. Sum of Left Leaves

[Problem link](https://leetcode.com/problems/sum-of-left-leaves/)

- My approach

Recursing solution, and set a variable to check if current node is a left child.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.res = 0
        
        def helper(n, left):
            if not n:
                return
            if not n.left and not n.right:
                if left:
                    self.res += n.val
                return
            helper(n.left, True)
            helper(n.right, False)
        
        helper(root, False)
        return self.res
```

And local result version:

```python
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        return self.recursive(root, 0, False)
        
        
    def recursive(self, root, sumi, isLeft):
        if not root:
            return sumi
        if isLeft and root and not root.left and not root.right:
            return sumi + root.val
        sumi = self.recursive(root.left, sumi, True)
        sumi = self.recursive(root.right, sumi, False)
        return sumi
```


## 405. Convert a Number to Hexadecimal

[Problem link](https://leetcode.com/problems/convert-a-number-to-hexadecimal/)

- My approach

For negative number m, the two's complement equals to `2^32 + n`.

Every time divide the number by 16, and add the remainder at the front of result.

```python
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return '0'
        if num < 0:
            num = 2**32 + num
        dic = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}
        res = ''
        while num > 0:
            curr = num % 16
            num = num // 16
            if curr < 10:
                res = str(curr) + res
            else:
                res = dic[curr] + res
        return res
```


## 406. Queue Reconstruction by Height  (Other's approach)

[Problem link](https://leetcode.com/problems/queue-reconstruction-by-height/)

- My approach

Divide the people by the number of larger front people(p[1]), and sort every group by decsending order.

For example:

```
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

{0: [[7, 0], [5, 0]],
 1: [[7, 1], [6, 1]], 
 2: [[5, 2]],
 4: [[4, 4]],} 
```

Then for the '0' group, just add it to the result in ascending order. And for other groups, traverse current result, and if find n people taller than current person which 
n equals to current p[1], insert current person at index+1.

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        dic = {}
        for p in people:
            if p[1] in dic:
                dic[p[1]].append(p)
            else:
                dic[p[1]] = [p]
        for k in dic:  # divide groups by the number of taller front people
            dic[k].sort()
            dic[k].reverse()
        print(dic)
        res = []
        for k in sorted(list(dic.keys())):
            for p in dic[k]:
                if not res:
                    res.append(p)
                    continue
                n = 0
                for i in range(len(res)):
                    if res[i][0] >= p[0]:
                        n += 1
                    if n >= p[1]:
                        if k == 0:
                            res.insert(i, p)
                        else:
                            res.insert(i+1, p)
                        break
                    
        return res
```

- Other's approach

There is a more simple solution.

Firstly sort the people by the descendong order of p[0], and ascending order of p[1].

For example:

```
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]
```

Now for every person, all the people before are taller than current p, so we can use its second element as index to insert it in result.

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people = sorted(people, key=lambda x: (-x[0], x[1]))
        queue = []
        for q in people:
            queue.insert(q[1], q)
        return queue
```


## 407. Trapping Rain Water II  (Use heap to sort the columns)

[Problem link](https://leetcode.com/problems/trapping-rain-water-ii/)

- Other's approach

Start from the edge, add all columns on edge firstly. Then every time pop the minimum one, find in its neighbors, if there is a nrighbor that smaller than current column, the 
neighbor must save the water, because current column is the smallest edge, and the water is `h-neighbor`. Then modify the neighbor to current height and add it into 
heap for next step.

```python
class Solution:
    def trapRainWater(self, heightMap):
        if not heightMap or not heightMap[0]:
            return 0
            
        rows, cols = len(heightMap), len(heightMap[0])
        water = 0
        q = []

        for r in range(rows):
            heapq.heappush(q, (heightMap[r][0], r, 0))    
            heapq.heappush(q, (heightMap[r][cols - 1], r, cols - 1))    
        for c in range(1, cols - 1):
            heapq.heappush(q, (heightMap[0][c], 0, c))    
            heapq.heappush(q, (heightMap[rows - 1][c], rows - 1, c))    
    
        visited = {(r, c) for _, r, c in q}

        while q:
            
            h, r, c = heapq.heappop(q)
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                r1, c1 = r + dr, c + dc
                if (r1, c1) not in visited and r1 >= 0 and c1 >= 0 and r1 < rows and c1 < cols:
                    visited.add((r1, c1))
                    water += max(0, h - heightMap[r1][c1])
                    heapq.heappush(q, (max(h, heightMap[r1][c1]), r1, c1))
                
        return water
```


## 409. Longest Palindrome

[Problem link](https://leetcode.com/problems/longest-palindrome/)

- My approach

All the numbers with even count can form in palindrome, and for the odd counts, we add count-1 into palindrome expect the max count(it can be at center).

```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        dic = {}
        for c in s:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        res = 0
        longestOdd = 0
        for k in dic:
            if dic[k] % 2 == 0:
                res += dic[k]
            else:
                if dic[k] > longestOdd:
                    if longestOdd > 0:
                        res += (longestOdd-1)
                    longestOdd = dic[k]
                else:
                    res += dic[k]-1
        
        return res + longestOdd
```

- Official solution

There is a simplified version. If the current result is even and meet an odd count, this number with odd count can all be added.

```python
class Solution:
    def longestPalindrome(self, s):
        ans = 0
        for v in collections.Counter(s).itervalues():
            ans += v / 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans
```


## 410. Split Array Largest Sum  (Other's approach)

[Problem link](https://leetcode.com/problems/split-array-largest-sum/)

- Other's approach

The key point is finding that for a given number target, if the array can be splited into k subarrays where `all the sums of the subarrays are less than target`, and `k is less 
than m`.

```python
class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:        
        def feasible(threshold) -> bool:
            count = 1
            total = 0
            for num in nums:
                total += num
                # total > threshold means the sum of current subarray is larger than threshold
                if total > threshold:
                    total = num
                    count += 1
                    # count > m means if we want to make all the sums of subarrays are less than threshold,
                    # we must split the array to more than m parts, it's unavailable
                    if count > m:
                        return False
            return True

        left, right = max(nums), sum(nums)
        while left < right:
            mid = left + (right - left) // 2
            if feasible(mid):
                right = mid     
            else:
                left = mid + 1
        return left
```

For more explanations, see [here](https://leetcode.com/problems/split-array-largest-sum/discuss/769701/Python-Clear-explanation-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems.)


## 412. Fizz Buzz

[Problem link](https://leetcode.com/problems/fizz-buzz/)

- My approach

Just check if the number is mutiple of 5 or mutiple of 3 or both.

```python
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1, n+1):
            if i % 3 == 0 and i % 5 == 0:
                res.append('FizzBuzz')
                continue
            if i % 3 == 0:
                res.append('Fizz')
            elif i % 5 == 0:
                res.append('Buzz')
            else:
                res.append(str(i))
        return res
```
