---
layout: article
tags: Leetcode Python
title: Leetcode problems 401-420
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 401 to 420, writing in Python.

<!--more-->

## 401. Binary Watch

[Problem link](https://leetcode.com/problems/binary-watch/)

- My approach

In my solution, the key idea is to find the m combination from a n-length array, here I use recursing.

```python
class Solution:
    def readBinaryWatch(self, num: int) -> List[str]:
        h = [1, 2, 4, 8]
        m = [1, 2, 4, 8, 16, 32]
        
        def helper(n, l):  # get n combination from l
            if n == 0:
                return [0]
            if n == 1:
                return l
            ans = []
            for i in range(len(l)):
                ans += [l[i]+j for j in helper(n-1, l[i+1:])]
            return ans
        
                        
        res = []
        for i in range(num+1):
            # i stands for there are i LEDs of hour are on, so there can be num-i LEDs of minute are on
            # h
            hours = helper(i, h)
            # m
            minutes = helper(num-i, m)
            # get all the possible combinations of hours and minutes, then compose them
            for hh in hours:
                if hh > 11:
                    continue
                for mm in minutes:
                    if mm > 59:
                        continue
                    if mm < 10:
                        res.append(str(hh) + ':0' + str(mm))
                    else:
                        res.append(str(hh) + ':' + str(mm))
        return res      
```


- Other's approach

For this problem, each LED stands for a number of `2^n`, so we can check for the bits of the numbers, a bit '1' can represent a lighting LED.

```python
class Solution:
    def readBinaryWatch(self, num: int) -> List[str]:
        res = []
        for i in range(0, 12):
            for j in range(0, 60):
                if  (bin(i)+bin(j)).count('1') == num:
                    res.append('%d:%02d'%(i,j))  # %02d to format the length
        return res
```


## 402. Remove K Digits  (Stack)

[Problem link](https://leetcode.com/problems/remove-k-digits/)

- My approach

Traverse from left to right, when meet a number that num[i] > num[i+1], pop num[i], do this for k times.

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        if len(num) == k:
            return '0'
        num = num + '0'
        for _ in range(k):
            if int(num) == 0:
                return '0'
            for i in range(len(num)-1):
                if num[i] > num[i+1]:
                    num = num[:i] + num[i+1:]
                    break
        n = int(num[:-1])
        return str(n)
```

The solution above has O(k*n) time complexity.

- Other's approach

This is a simplified solution by using stack. Save the numbers in stack from left to right, and when meet a number that is less than stack[-1], 
pop all the larger numbers at the end of stack. And do this for k times.

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        
        for n in num:
            while stack and stack[-1] > n and k > 0:
                k -= 1
                stack.pop()
            stack.append(n)
        
        while k > 0:
            stack.pop()
            k -= 1
        
        if not stack:
            return '0'
        
        return str(int(''.join(stack)))
```


## 403. Frog Jump  (Dynamic programming)

[Problem link](https://leetcode.com/problems/frog-jump/)

- My approach

My own recursing solution was time limited exceeded.

- Other's approach

Use dynamic programming, save the structure as `{stone:(the steps taked to jump to this stone)}`.

Then traverse the given stones, for each stone, the next stone it can reach will be in `stone + (step-1, step, step+1)`.

After dealing with all the stones, if can jump to the final stone, there must be some values in the dic[final_stone].

```python
class Solution:
    def canCross(self, stones: List[int]) -> bool:
        dic = {i:set() for i in stones}
        dic[0] = {0}
        
        for stone in stones:
            for step in dic[stone]:
                for jump in (step-1, step, step+1):
                    nextStone = stone + jump  # The next stone can be reached
                    if nextStone != stone and nextStone in dic:
                        dic[nextStone].add(jump)
        
        return len(dic[stones[-1]]) > 0
```


## 404. Sum of Left Leaves

[Problem link](https://leetcode.com/problems/sum-of-left-leaves/)

- My approach

Recursing solution, and set a variable to check if current node is a left child.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        self.res = 0
        
        def helper(n, left):
            if not n:
                return
            if not n.left and not n.right:
                if left:
                    self.res += n.val
                return
            helper(n.left, True)
            helper(n.right, False)
        
        helper(root, False)
        return self.res
```

And local result version:

```python
class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        return self.recursive(root, 0, False)
        
        
    def recursive(self, root, sumi, isLeft):
        if not root:
            return sumi
        if isLeft and root and not root.left and not root.right:
            return sumi + root.val
        sumi = self.recursive(root.left, sumi, True)
        sumi = self.recursive(root.right, sumi, False)
        return sumi
```


## 405. Convert a Number to Hexadecimal

[Problem link](https://leetcode.com/problems/convert-a-number-to-hexadecimal/)

- My approach

For negative number m, the two's complement equals to `2^32 + n`.

Every time divide the number by 16, and add the remainder at the front of result.

```python
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return '0'
        if num < 0:
            num = 2**32 + num
        dic = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}
        res = ''
        while num > 0:
            curr = num % 16
            num = num // 16
            if curr < 10:
                res = str(curr) + res
            else:
                res = dic[curr] + res
        return res
```
