---
layout: article
tags: Leetcode Python
title: Leetcode problems 381-400
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 381 to 400, writing in Python.

<!--more-->

## 381. Insert Delete GetRandom O(1) - Duplicates allowed

[Problem link](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

- My approach

An extension of [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/).

There are dpulicates, so we need to store the indexes of the same number. Here we use collection.

```python
class RandomizedCollection:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = collections.defaultdict(set)
        self.l = []
        

    def insert(self, val: int) -> bool:
        """
        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.
        """
        ret = True
        if val in self.d:
            ret = False
        self.l.append(val)
        self.d[val].add(len(self.l)-1)
        return ret
        

    def remove(self, val: int) -> bool:
        """
        Removes a value from the collection. Returns true if the collection contained the specified element.
        """
        if not self.d[val]:
            return False
        else:
            idx = self.d[val].pop()  # get one index randomly
            last = self.l[-1]
            self.l[idx] = last  # modify it in list

            self.d[last].add(idx)  # modify it in dictionary
            self.d[last].discard(len(self.l)-1)
            self.l.pop()
            return True
        
        

    def getRandom(self) -> int:
        """
        Get a random element from the collection.
        """
        return random.choice(self.l)
        


# Your RandomizedCollection object will be instantiated and called as such:
# obj = RandomizedCollection()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```


## 382. Linked List Random Node

[Problem link](https://leetcode.com/problems/linked-list-random-node/)

- My approach

Store the values in a list, and use `random.choice()` to get values randomly.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:

    def __init__(self, head: ListNode):
        """
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """
        self.l = []
        while head:
            self.l.append(head.val)
            head = head.next

    def getRandom(self) -> int:
        """
        Returns a random node's value.
        """
        return random.choice(self.l)
        


# Your Solution object will be instantiated and called as such:
# obj = Solution(head)
# param_1 = obj.getRandom()
```

- Follow up

This problem has a follow-up version: if the length of linked list is very large and we don't know, how to get random value?

Traverse the linked list, and for every node, we have a probability to modify it or not, the probability equals to `1/n`, which n is the index of node.

So the probability of one node can reach the end equals to `1* 1/2 * 1/3 * ... * 1/n`.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:

    def __init__(self, head: ListNode):
        """
        @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node.
        """
        self.n = head

    def getRandom(self) -> int:
        """
        Returns a random node's value.
        """
        count = 1
        curr = self.n
        val = curr.val
        
        while curr.next:
            num = random.random()
            count += 1
            if num <= (1/count):  # modify
                val = curr.next.val
            curr = curr.next
        return val
        


# Your Solution object will be instantiated and called as such:
# obj = Solution(head)
# param_1 = obj.getRandom()
```


## 383. Ransom Note

[Problem link](https://leetcode.com/problems/ransom-note/)

- My approach

Save characters in dictionary and check if the count of characters in magazine is enough for ransom

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        dic = {}
        for s in magazine:
            if s in dic:
                dic[s] += 1
            else:
                dic[s] = 1
        
        for s in ransomNote:
            if s not in dic or dic[s] == 0:
                return False
            else:
                dic[s] -= 1
        return True
```


## 384. Shuffle an Array

[Problem link](https://leetcode.com/problems/shuffle-an-array/)

- My approach

Every time choose an element randomly, add it at the end of result, and delete it from the original array.

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.l = nums
        self.c = set(nums)
        

    def reset(self) -> List[int]:
        """
        Resets the array to its original configuration and return it.
        """
        return self.l
        

    def shuffle(self) -> List[int]:
        """
        Returns a random shuffling of the array.
        """
        res = []
        curr = self.c.copy()
        while curr:
            n = random.choice(list(curr))
            res.append(n)
            curr.remove(n)
        return res
```


## 385. Mini Parser

[Problem link](https://leetcode.com/problems/mini-parser/)

- My approach

Firstly traverse the string into a nested list, then construct it to the structure recursively.

```python
# """
# This is the interface that allows for creating nested lists.
# You should not implement it, or speculate about its implementation
# """
#class NestedInteger:
#    def __init__(self, value=None):
#        """
#        If value is not specified, initializes an empty list.
#        Otherwise initializes a single integer equal to value.
#        """
#
#    def isInteger(self):
#        """
#        @return True if this NestedInteger holds a single integer, rather than a nested list.
#        :rtype bool
#        """
#
#    def add(self, elem):
#        """
#        Set this NestedInteger to hold a nested list and adds a nested integer elem to it.
#        :rtype void
#        """
#
#    def setInteger(self, value):
#        """
#        Set this NestedInteger to hold a single integer equal to value.
#        :rtype void
#        """
#
#    def getInteger(self):
#        """
#        @return the single integer that this NestedInteger holds, if it holds a single integer
#        Return None if this NestedInteger holds a nested list
#        :rtype int
#        """
#
#    def getList(self):
#        """
#        @return the nested list that this NestedInteger holds, if it holds a nested list
#        Return None if this NestedInteger holds a single integer
#        :rtype List[NestedInteger]
#        """

class Solution:
    def deserialize(self, s: str) -> NestedInteger:
        if s[0] != '[':
            return NestedInteger(int(s.split(',')[0]))
        
        # Transerve the string into nested list
        l = []
        stack = [l]
        i = 0
        while i < len(s):
            if s[i] == '[':
                next_level = []
                stack[-1].append(next_level)
                stack.append(next_level)
            elif s[i] == ']':
                stack.pop()
            elif s[i] in '0123456789-':
                start = i
                while s[i] in '0123456789-':
                    i += 1
                stack[-1].append(int(s[start:i]))
                i -= 1
            i += 1
        
        def helper(sl):
            res = NestedInteger()
            if type(sl) == int:
                res.setInteger(sl)
            else:
                res = NestedInteger()
                for ssl in sl:
                    res.add(helper(ssl))
            return res
        
        return helper(l[0])
```


## 386. Lexicographical Numbers

[Problem link](https://leetcode.com/problems/lexicographical-numbers/)

- My approach

Think the numbers as a tree, which the children are based on the root, like this:

```
   1       2           9
 /   \   /  \         /  \
10...19 20...29 ...  90...99
```

We do `DFS` of these trees from left to right, the order will be lexicographical order.

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        self.res = []
        def helper(curr):
            if curr > n:
                return
            self.res.append(curr)
            for i in range(10):
                if curr*10+i > n:
                    return
                helper(curr*10+i)  # dfs
                
        for i in range(1, 10):
            helper(i)
        return self.res
```


## 387. First Unique Character in a String

[Problem link](https://leetcode.com/problems/first-unique-character-in-a-string/)

- My approach

Save the characters and their counts in a dictionary, then traverse the array and find the first character that its value in dictionary is 1.

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        dic = {}
        for c in s:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        for i in range(len(s)):
            if dic[s[i]] == 1:
                return i
        return -1
```


## 388. Longest Absolute File Path

[Problem link](https://leetcode.com/problems/longest-absolute-file-path/)

- My approach

Save the directories in a dictionary by their level. For example, if the given string is:

```
"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"
```

then the dictionary will be:

```
{
  1: ['dir'], 
  2: ['subdir1', 'subdir2'], 
  3: ['subsubdir1', 'subsubdir2']
}
```

When meet a string that contains '.', means it's a file, then the whole path is the sum of all the `dic[i][-1]`(i is the lower levels than current file level).

```python
class Solution:
    def lengthLongestPath(self, _input: str) -> int:
        dic = collections.defaultdict(list)
        self.res = 0
        
        def helper(idx, level):
            if idx >= len(_input):
                return
            if _input[idx] == '\n':
                curr = idx+1
                while _input[curr] == '\t':
                    curr += 1
                helper(curr, curr-idx)  # curr-idx is the length of '\n\t...', it can stand for the level of directory
            else:
                curr = idx
                isFile = False
                while curr < len(_input) and _input[curr] != '\n':
                    if _input[curr] == '.':
                        isFile = True
                    curr += 1
                if isFile:
                    length = curr - idx
                    for i in range(1, level):
                        length += len(dic[i][-1])+1  # 1 stands for '\'
                    self.res = max(self.res, length)  # if meet a file, calculate the length
                else:
                    dic[level].append(_input[idx:curr])  # if meet a directory, add it into dic
                helper(curr, level)
        
        helper(0, 1)
        return self.res
```


## 389. Find the Difference

[Problem link](https://leetcode.com/problems/find-the-difference/)

- My approach

Save the characters as {character:count} in dictionary, and find the different count.

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        dic = {}
        for c in t:
            if c in dic:
                dic[c] += 1
            else:
                dic[c] = 1
        
        for c in s:
            dic[c] -= 1
            if dic[c] == 0:
                dic.pop(c)
        
        return list(dic.keys())[0]
```

## 390. Elimination Game

[Problem link](https://leetcode.com/problems/elimination-game/)

- My approach

I used step-by-step method, but it was time limited exceeded.

- Other's approach

Every time the interval of numbers are increasing by 2, if we can find the start number, then we can confirm all the numbers.

See the [explanation](https://leetcode.com/problems/elimination-game/discuss/699816/Python-simple-solution-with-examples)

```python
class Solution:
    def lastRemaining(self, n: int) -> int:
        i = 0
        start = 1
        diff = 1
        while( n > 1 ):
            i += 1
            if( i == 1):
                start = 2
            n = n // 2
            if(n == 1):
                return start
            diff = diff * 2
            #1 #3
            # when, we have odd number of elements and level is reverse level i.e i % 2 ==1, then starting ele will be deleted, so our start will be start + diff (check above examples)
            #2
            if( (i % 2 == 1 and n % 2 == 1) or (i % 2 == 0) ): start = start + diff
        return start
```


## 391. Perfect Rectangle

[Problem link](https://leetcode.com/problems/perfect-rectangle/)

- My approach

If the rectangles can build up a perfect rectangle, the sum of all the areas of rectangles must equal to the area of the perfect rectangle. And the final figure must have 
just 4 points(left-bottom, right-bottom, left-top and right-top).

```python
class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        mem = set()
        area = 0
        
        for r in rectangles:
            left_bottom = (r[0], r[1])
            right_bottom = (r[2], r[1])
            left_top = (r[0], r[3])
            right_top = (r[2], r[3])
            area += (r[2]-r[0]) * (r[3]-r[1])
            for p in (left_bottom, right_bottom, left_top, right_top):
                if p in mem:  # if p in mem, means current point is merged by two rectangles, so it is not a edge point now
                    mem.remove(p)
                else:
                    mem.add(p)
        if len(mem) != 4:
            return False
        rt, lb = max(mem), min(mem)
        if area == (rt[0]-lb[0])*(rt[1]-lb[1]):
            return True
        return False
```


## 392. Is Subsequence

[Problem link](https://leetcode.com/problems/is-subsequence/)

- My approach

Use two pointers and check if t[i] == s[j] in order.

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if not s:
            return True
        i_s = i_t = 0
        while i_t < len(t):
            if s[i_s] == t[i_t]:
                i_s += 1
            i_t += 1
            if i_s == len(s):
                return True
        return False
```


## 393. UTF-8 Validation

[Problem link](https://leetcode.com/problems/utf-8-validation/)

- My approach

Use `bin()` to converse numbers into binary string, and check them by the given rules.

```python
class Solution:
    def validUtf8(self, data: List[int]) -> bool:
        d = [n&255 for n in data]
        i = 0
        while i < len(d):
            if d[i] < 128:  # d[i]<128 means it starts with 0
                i += 1
            else:
                b = bin(d[i])[2:]
                if b[:2] == '10':  # '10' can only follow with `11x`
                    return False
                j = 0  # the count of 1 
                while j < len(b) and b[j] == '1':
                    j += 1
                if j > 4:  # there can be at most 4 bytes
                    return False
                for k in range(1, j):  # all the j-1 numbers followed must start with '10'
                    if i+k > len(d)-1 or d[i+k] < 128 or bin(d[i+k])[2:4] != '10':
                        return False
                i += j
        return True
```


## 394. Decode String

[Problem link](https://leetcode.com/problems/decode-string/)

- My approach

Use recursing method, and deal with the substring in `[]` as a new string.

```python
class Solution:
    def decodeString(self, s: str) -> str:
        
        def helper(st):
            i = 0
            res = ''
            while i < len(st):
                if st[i] in '1234567890':
                    num = 0
                    while st[i] in '1234567890':
                        num = num*10 + int(st[i])
                        i += 1
                    # inBracket[0] is the substring in '[]', inBracket[1] is the index of the end of ']'
                    inBracket = helper(st[i+1:])
                    res += num * inBracket[0]
                    i += inBracket[1]+1  # calculate the next index
                elif st[i] not in '1234657890' and st[i] != ']':  # common characters
                    res += st[i]
                    i += 1
                elif st[i] == ']':  # ']' means one substring is over
                    return (res, i+1)
            return (res, i+1)
            
        return helper(s)[0]
```

- Other's approach

We can also solve this problem by iterator method with stack.

The key point is: for nested brackets, when we solve one bracket, add it back to stack, so it can be added into the larger bracket.

```python
class Solution:
    def decodeString(self, s: str) -> str:
        
        stack = []
        i = 0
        res = ''
        for i in s:
            if i == ']':
                curr = ''
                while stack[-1] != '[':
                    curr = stack.pop() + curr
                stack.pop()
                num = ''
                while stack and stack[-1] in '1234567890':
                    num = stack.pop() + num
                for c in int(num) * curr:  # add the string back to stack
                    stack.append(c)
            else:
                stack.append(i)
        
        return ''.join(stack)

```


## 395. Longest Substring with At Least K Repeating Characters

[Problem link](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/)

- My approach

Use the method of `divide and conquer`. Find the characters which count is smaller than k, and divide the string at these characters. Then do the same operation of the 
substrings until find a substring that all the counts of characters are no less than k.

For example:

```
s = "aabcbd", k = 2

the count of c and d are smaller than k, so we divide the string at c and d: ["aab", "b"], and go on for these substrings.
```

```python
class Solution:
    def longestSubstring(self, s: str, k: int) -> int:
        self.res = 0
        
        def helper(st):
            # Find the small-count characters
            dic = {}
            for i in st:
                if i in dic:
                    dic[i] += 1
                else:
                    dic[i] = 1
            notEnough = set()
            for j in dic:
                if dic[j] < k:
                    notEnough.add(j)
                  
            if not notEnough:
                self.res = max(self.res, len(st))
                return
            else:
                t = 0
                start = 0
                while t < len(st):  # divide the string
                    if st[t] in notEnough and start >= 0:
                        helper(st[start:t])
                        t += 1
                        start = -1
                    else:
                        if start < 0:
                            start = t
                        t += 1
                if start > 0:
                    helper(st[start:])
                    
        helper(s)
        return self.res
```

- Slide Window

The [official solution](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/) provides a slide window method.


## 396. Rotate Function  (Other's approach)

[Problem link](https://leetcode.com/problems/rotate-function/)

- Other's approach

It's like a mathematical method. Since every time rotate the last number to front, all other numbers will be from A[i]*(i-1) to A[i]*i, so we can calculate the sum of A firstly, 
if current sum=num, next sum will be `num-(last_number)*(n-1)+(sum_of_A)-(last-number)`(because las_number add to front will be last_number*0), it can be simplified as 
`num - (last_number)*n + sum_of_A`.

```python
class Solution:
    def maxRotateFunction(self, A: List[int]) -> int:
        num = sum(i*A[i] for i in range(len(A)))
        res = num
        s = sum(A)
        n = len(A)
        for i in range(len(A)):
            new_num = num - A[n-i-1]*n + s
            res = max(res, new_num)
            num = new_num
        return res
```


## 397. Integer Replacement  (Recursing with memory)

[Problem link](https://leetcode.com/problems/integer-replacement/)

- My approach

Recursing method:

```python
class Solution:
    def integerReplacement(self, n: int) -> int:
        self.res = float('inf')
        def helper(num, step):
            if num == 1:
                self.res = min(self.res, step)
                return
            if num % 2 == 0:
                helper(num//2, step+1)
            else:
                helper((num+1)//2, step+2)
                helper((num-1)//2, step+2)
        
        helper(n, 0)
        return self.res
```

Recursing with memory:

```python
class Solution:
    def integerReplacement(self, n: int) -> int:
        self.dp = {}
        
        def helper(num):
            if num == 1:
                return 0
            if num in self.dp:
                return self.dp[num]
            if num % 2 == 0:
                self.dp[num] = helper(num//2) + 1
            else:
                self.dp[num] = min(helper((num-1)//2), helper((num+1)//2)) + 2
            return self.dp[num]
        
        res = helper(n)
        return res
```


## 398. Random Pick Index

[Problem link](https://leetcode.com/problems/random-pick-index/)

- My approach

Save indexes of same value in a dictionary. And find randomly in dic[target].

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.dic = {}
        for idx, val in enumerate(nums):
            if val in self.dic:
                self.dic[val].append(idx)
            else:
                self.dic[val] = [idx]

    def pick(self, target: int) -> int:
        l = self.dic[target][:]
        for i in range(1, len(l)):
            p = 1/(i+1)
            n = random.random()
            if n > p:
                l[i] = l[i-1]
        return l[-1]
```

And this can be improved. Just traverse the array and when meet a target number, calculate the probability to ckeck if modify the answer. So we don't need the extra dictionary.

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums

    def pick(self, target: int) -> int:
        count = 0
        last_idx = 0
        res = 0
        for idx, val in enumerate(self.nums):
            if val == target:
                count += 1
                p = 1 / count
                n = random.random()
                if n > p:  # if random number is larger than current probability, modify it with the last result
                    res = last_idx
                else:
                    res = idx
                    last_idx = idx
        return res


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.pick(target)
```


## 399. Evaluate Division  (Graph and DFS)

[Problem libk](https://leetcode.com/problems/evaluate-division/)

- Other's approach

We can see the structure as a directed graph, and the nodes are the characters in equations, the lines are the quotient fron head to tail.

Then we can do DFS for this graph, if the two nodes are not connected, return -1.

```python
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        dic = collections.defaultdict(dict)
        for i in range(len(equations)):
            dic[equations[i][0]][equations[i][1]] = values[i]
            dic[equations[i][1]][equations[i][0]] = 1 / values[i]

        def helper(x, y, visited):
            if x not in dic and y not in dic:
                return -1
            if y in dic[x]:
                return dic[x][y]
            for i in dic[x]:
                if i not in visited:
                    visited.add(i)
                    # we want to get the result of x->y, if y is not connect directly with x, find deeperly
                    curr = helper(i, y, visited)
                    if curr == -1:
                        continue  # find next
                    return dic[x][i] * curr
            return -1
        
        res = []
        for a, b in queries:
            res.append(helper(a, b, set()))
        
        return res
```


## 400. Nth Digit

[Problem link](https://leetcode.com/problems/nth-digit/)

- My approach

There is a regular that th whole length of t-bit numbers equals to `t*9*10^(t-1)`(0-9, 10-99 ...).

So we can firstly determine the length of the number which contains nth digit.

After finding out the length, we can know which is the number by using the rmained n. And let `r=n%t`, so r means the index of the digits.

```python
class Solution:
    def findNthDigit(self, n: int) -> int:
        t = 1
        j = 9
        while n > j:
            n -= j
            t += 1
            j = t * 9 * 10**(t-1)
        
        q = n // t  # means there are q numbers between target number and the start of t-length number
        r = n % t  # r means the target digit is rth of target number
             
        if r == 0:  # the last digit of previous number
            return (10**(t-1)+q-1) % 10
        else:
            s = str(10**(t-1)+q)
            return s[r-1]
```
