---
layout: article
tags: Leetcode Python
title: Leetcode problems 21-40
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 21 to 40, writing in Python.

<!--more-->

## 81.Search In Rotated Sorted Array 2

[Problem link](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

- My approach

The given list is a sortd list, but cut off at a random position. So we can just compare the first and last number with target number. 
And then do the same thing as [Search in Rotated Sorted Array](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/SearchInRotatedSortedArray.md)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if not nums:
            return False
        # Check the first number
        if target >= nums[0]:
            for i in nums:
                if i == target:
                    return True
        else:
            # Check the last number
            if target <= nums[-1]:
                for j in range(len(nums)):
                    if nums[len(nums)-j-1] < target:
                        return False
                    if nums[len(nums)-j-1] == target:
                        return True
            else:
                return False
        return False
```


## 82.Remove Duplications From Sorted List 2

[Problem link](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)

- My approach

The idea is very simple: Traverse the sorted list from start to end, and delete the duplicated nodes.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        res = a = ListNode(0)
        num = head.val
        n = head.next
        # To end the loop, firstly add a flag at the end of given listnode
        while head.next:
            head = head.next
        head.next = ListNode('a')
        while n:
            # At the beginning of the loop, n stands for current node, num stands for the value of last node
            # If there are duplications, go on until next value
            if n.val == num:
                while n.val == num:
                    n = n.next
                num = n.val
                n = n.next
            # If there is no duplication, add ListNode(num) to the end of res
            else:
                a.next = ListNode(num)
                a = a.next
                num = n.val
                n = n.next
        return res.next
```

- Other's approach

There is an in-place method from others. The key idea is using two pointers.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if head is None:
            return 
        
        dummy = ListNode(0)
        # Set two pointers
        prev = dummy
        dummy.next = head
        
        while head and head.next:
            if head.val == head.next.val:
                while head and head.next and head.val == head.next.val:
                    head = head.next
                head = head.next
                prev.next = head
            else:
                prev = prev.next
                head = head.next
        return dummy.next
```


## 83.Remove Duplications From Sorted List

[Problem link](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)

- My approach

This problem is simplified [Remove Duplications From Sorted List 2](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/RemoveDuplicationsFromSortedList2.md)

Just traverse given list and remove duplications in-place.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        n = head
        while n:
            num = n.val
            # If there are duplications, skip them
            while n.next and n.next.val == num:
                n = n.next
            n = n.next
            head.next = n
            head = head.next
        return dummy.next
```


## 84.Largest Rectangle In Histogram (Other's approach)


[Problem link](https://leetcode.com/problems/largest-rectangle-in-histogram/)

- My approach

This is a hard problem, my approaches were all time exceeded.

- Other's approach

This approach uses a stack to store some ascending parts(like [1, 3, 5, 6] in [2, 1, 3, 5, 6, 2]).
And when the height of current bar is smaller than the last bar in stack, go to calculate the area.

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        stack = []
        res = 0
        # Firstly add a [0] at the beginning and end
        heights = [0] + heights + [0]
        for i in range(len(heights)):
            # If current height is smaller than the last one in stack, means the start of 'ascending sequence' needs to change
            # and before change it, calculate the area with the bars in stack now.
            while stack and heights[stack[-1]] > heights[i]:
                crt = stack.pop(-1)
                # Because it's ascending order, the largest area of current bar equals to (the height of current bar) * (the distance
                # between current bar and the rightest bar in ascendng order)
                res = max(res, (i-stack[-1]-1)*heights[crt])
            stack.append(i)
        return res
            
```


## 85.Maximal Rectangle

[Problem link](https://leetcode.com/problems/maximal-rectangle/)

- My approach

This problem is an extention of [Largest Rectangle In Histogram](https://github.com/Chunar5354/some_notes/blob/master/leetcode/problems/LargestRectangleInHistogram.md).

Firstly convert the matrix into bar chart(x-axis stands for the columns, y-axis stands for height of columns). 
Then use the method of calculating the maximum area of bar chart for each layer.

```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        res = 0
        m = len(matrix)
        n = len(matrix[0])
        # Set the x-axis of bar chart
        bar_list = [0] * n
        for i in range(m):
            for j in range(n):
                # If current position is '1', means the height of current bar should plus 1
                if matrix[i][j] == '1':
                    bar_list[j] += 1
                # If current position is '0', means the bar is cut here, so the height of current bar should be reset to 0
                else:
                    bar_list[j] = 0
            # Calculate the max area of current layer
            res = max(res, self.getArea(bar_list))
        return res
    
    # The same method of 'Largest Rectangle In Histogram'
    def getArea(self, l):
        print(l)
        stack = []
        ans = 0
        l = [0] + l + [0]
        for i in range(len(l)):
            while stack and l[i] < l[stack[-1]]:
                # print(stack, l[i])
                crt_h = stack.pop(-1)
                ans = max(ans, (i-stack[-1]-1)*l[crt_h])
            stack.append(i)
        return ans
```


## 86.Partition List

[Problem link](https://leetcode.com/problems/partition-list/)

- My approach

Create two linked lists to store the less nodes and larger nodes, then link the large list at the end of less list.

```pyhon
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        # Create two linked lists
        less_head = le = ListNode(0)
        large_head = la = ListNode(0)
        n = head
        while n:
            if n.val < x:
                le.next = n
                le = le.next
            else:
                la.next = n
                la = la.next
            n = n.next
        la.next = None
        # Link the large list at the end of less list
        le.next = large_head.next
        return less_head.next
```


## 87.Scramble String  (DFS method)

[Problem link](https://leetcode.com/problems/scramble-string/)

This problem is a little difficult so I didn't solve it.

- Other's approach

I searched for other's approach, and there is a good solution by using `DFS` (depth first search) method.

```python
class Solution:
    def isScramble(self, s1: str, s2: str) -> bool:
        '''
        作为一个递归函数，它将返回一个bool值
        每次传入的s1和s2视为上一层字符串的一个分支
        '''
        if not s1 or not s2 or len(s1) != len(s2):
            return False
        # 如果s1和s2中的字母不相同的话，那么当前的两个分支肯定不能相等
        if sorted(s1) != sorted(s2):
            return False
        if s1 == s2:
            return True  
        for i in range(1, len(s1)):
            # 要满足的条件为：s1的前i项和s2的前i项相等并且s1的后i项和s2的后i项相等
            # 或者s1的前i项和s2的后i项相等并且s1的后i项和s2的前i项相等
            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(1[i:], s2[i:])) \
                or (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):
                return True
        
        return False
```


## 88.Merge Sorted Array

[Problem link](https://leetcode.com/problems/merge-sorted-array/)

- My approach

Just compare the elements in nums1 and nums2, and add nums2 into nums1. But pay attention to the limit of length.

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i = 0
        for j in range(n):
            # Skip the elements which are smaller than current nums2[j]
            while nums1[i] <= nums2[j] and i < m+j:
                i += 1
            # Firstly move the next (m+j-i) elements of current nums1[i], then add nums2[j] into nums1[i]
            for k in range(m+j-i):
                nums1[m+j-k] = nums1[m+j-k-1]
            nums1[i] = nums2[j]
```

This method is not very clearly, I found an other's method which is more clearly.

- Other's approach

This approach adds the elements from right to left, so it can avoid the moving operations.

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        while m > 0 and n > 0:
            # We only need to deal with the first m elements in nums1, and first n elements in nums2
            if nums1[m-1] >= nums2[n-1]:
                nums1[m+n-1] = nums1[m-1]
                m -= 1
            else:
                nums1[m+n-1] = nums2[n-1]
                n -= 1
        if n > 0:
            nums1[:n] = nums2[:n]
```


## 89.Gray Code



[Problem link](https://leetcode.com/problems/gray-code/)

- My approach

`Two number differ in only one bit` means XOR（异或） these two numbers, and the answer will only have one '1' in all the bits.

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        res = [0]
        for _ in range(2**n):
            for j in range(n):
                # XOR the last number in res and current 2**j
                # becaues 2**j has only one '1' bit
                num = abs(res[-1]^(2**j))
                if num not in res:
                    res.append(num)
                    break
        return res
```

And there is a very smart method from others.

- Other's approach

```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        res = []
        for i in range(2 ** n):
            res.append(i ^ (i >> 1))    # I want to know why?
        return res
```

I think it's a mathematical magic.

### Knowledge

In Python, XOR operation is `a ^ b`
