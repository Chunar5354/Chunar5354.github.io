---
layout: article
tags: Leetcode Python
title: Leetcode problems 321-340
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 321 to 340, writing in Python.

<!--more-->

## 321. Create Maximum Number  (Other's approach)

[Problem link](https://leetcode.com/problems/create-maximum-number/)

- Other's approach

There is a very smart method.

He divided the operation to 2 parts, firstly find i maximum numbers of nums1 and k-i maximum numbers of nums2, then get the maximum combination of them.

```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def prep(nums, k):
            '''
            Find k manimum numbers of nums in origin order
            '''
            drop = len(nums) - k
            out = []
            for num in nums:
                while drop and out and out[-1] < num:
                    out.pop()
                    drop -= 1
                out.append(num)
            return out[:k]

        def merge(a, b):
            '''
            The maximum combination of a and b
            '''
            return [max(a, b).pop(0) for _ in a+b]


        res = []
        for i in range(k+1):
            if i <= len(nums1) and k-i <= len(nums2):
                res.append(merge(prep(nums1, i), prep(nums2, k-i)))
        return max(res)
```


## 322. Coin Change  (Greedy-dynamic program)

[Problem link](https://leetcode.com/problems/coin-change/)

- My pproach

My recursing method was time limit exceeded.

- Official solution

The best way to solve this kind of greedy problem is dynamic program.

dp[x] stands for the minimum coins for x money.

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 
```


## 324. Wiggle Sort II

[Problem link](https://leetcode.com/problems/wiggle-sort-ii/)

- My approach

Firstly sort the array then divide the sorted array at the middle. Then add elements from small part and large part alternatelly.

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort()
        
        small = nums[:(len(nums)+1)//2]
        large = nums[(len(nums)+1)//2:]

        while nums:
            nums.pop()
        while small:
            nums.append(small.pop())
            if large:
                nums.append(large.pop())
        if large:
            nums.append(large.pop())
```

- Other's approach

An O(1) space complex method.

```python
class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        nums.sort() 
        half = len(nums[::2])
        nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1]
```


## 326. Power of Three

[Problem link](https://leetcode.com/problems/power-of-three/)

- My approach

Multiply 3 until num is larger or equal to n. Then check if num equals to n.

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n == 0:
            return False
        return math.log(n, 3) % 1 == 0
```

Or using `log` to calculate the logarithm of n-3. If n is a power of 3, the logarithm will be an integer.

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        if n == 1:
            return True
        return math.log10(n) / math.log10(3) % 1 == 0
```

Attention here, using math.log(n, 3) may cause float overflow. For example, the result of math.log(243, 3) is 4.99999.


## 327. Count of Range Sum  (Binary search tree)

[Problem link](https://leetcode.com/problems/count-of-range-sum/)

- My approach

O(n^2) method was time limited exceeded.

- Other's approach

[Here](https://leetcode.com/problems/count-of-range-sum/discuss/78016/Very-concise-solution-in-Python-with-explanation) is a method from others.

He changes sum(i, j) into `sum(0, j) - sum(0, i)`, and uses binary search tree to sort the sums.

```python
class Solution(object):
    def countRangeSum(self, nums, lower, upper):
        prefix,thisSum,ans = [0],0,0
        # the elemens in prefix stands for sum(0, i) for every i < j, which j is current position
        for n in nums:
            thisSum += n
            # bisect_right and bisect_left return the index to insert thisSum-lower or thisSum-upper into prefix.
            # The different of them is how many available sums in this loop
            # We set x to stand for numbers in prefix, x < thisSum-lower equals to thisSum-x > lower, 
            # thisSum is sum(0, j), x is sum(0, i) so thisSum-x is sum(i, j), so as thisSum-upper
            ans += bisect.bisect_right(prefix, thisSum-lower) - bisect.bisect_left(prefix, thisSum-upper)
            bisect.insort(prefix, thisSum)
        return ans
```
