---
layout: article
tags: Leetcode Python
title: Leetcode problems 1-20
article_header:
  type: overlay
  theme: dark
  background_color: '#123'
  background_image: false
---

Leetcode problems from 1 to 20, writing in Python.

<!--more-->

## Problem 1

[题目链接](https://leetcode.com/problems/two-sum/)

第一次在LeetCode刷题，上来就hardcode了一个：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        return_list = []
        for i in range(len(nums)):
            first_num = nums[i]
            for j in range(len(nums)):
                if j != i:
                    if first_num + nums[j] == target:
                        return_list.append(i)
                        return_list.append(j)
                        return return_list
                    else:
                        pass
```

少量数据测试的时候完全没问题（甚至还最短），但是submit的时候就超时了

第二次用了`enumerate()`函数，成功通过了，但成绩不太理想：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, fir in enumerate(nums):
            sec = target - fir
            if sec in nums and nums.index(sec) != i:
                return [i, nums.index(sec)]
            else:
                pass
```

问题应该是出在了多次进行的`index()`查找索引值上

最后看了别人的solutions，最快的方法是使用hash表（Python中的dict）：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        h = {}
        for i, num in enumerate(nums):
            n = target - num
            if n not in h:
                h[num] = i
            else:
                return [h[n], i]
```

### 结论

对于这种需要查找索引值以及数值的问题，在数据量大的情况下，应该优先考虑使用类字典的存储方式

### 知识点

hashmap：java中的一种数据结构，可类比于python中的字典结构

hashmap中元素的存储位置是由key的hashcode和hashmap的长度计算出来的[参考](https://zhuanlan.zhihu.com/p/31610616)

hashmap的扩展长度必须是2的n次方（为计算存储位置考虑）

- 区别：
    - 1.hashmap的初始长度，在java中是16，python中是8
    - 2.在java中，hashmap的结构是`数组+链表`，当存在冲突的时候，会将新元素存放在该地址对应的链表中的下一个结点；在python中使用的
    是开放寻址法[参考](https://www.cnblogs.com/lianzhilei/p/9275115.html)，存在冲突时会继续向下扩展存储单元，找到新的合适地址
    

## Problem 2

[题目链接](https://leetcode.com/problems/add-two-numbers/)

仍然是自己hardcode了一个（其实也写了好久），对数据结构还是不太熟悉，要在Python中实现一个链表，自己首先想到的还是借助Python的对象，
最后是使用列表实现的，当然成绩很不理想啦：
```python
class Solution:
    def getlist(self, l, l_list):
        if l.next != None:
            self.getlist(l.next, l_list)
            l_list.append(l.val)
        else:
            l_list.append(l.val)
        return l_list   
    
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        l1_num = []
        l2_num = []
        sum = 0
        l1_num = self.getlist(l1, l1_num)
        l2_num = self.getlist(l2, l2_num)
        n = max(len(l1_num), len(l2_num))
        for i in range(n):
            if len(l1_num) > 0:
                l1_val = l1_num.pop(-1)
            else:
                l1_val = 0
            if len(l2_num) > 0:
                l2_val = l2_num.pop(-1)
            else:
                l2_val = 0
            sum += (l1_val + l2_val) * 10 ** (i)
        if sum == 0:
            return ListNode(0)
        else:
            s_sum = str(sum)
            res = {}
            for i in range(len(s_sum)):
                if i == 0:
                    res[i] = ListNode(int(s_sum[i]))
                    res[i].next = None
                else:
                    res[i] = ListNode(int(s_sum[i]))
                    res[i].next = res[i-1]
            return res[len(s_sum)-1]
```
其实绕了很多弯路，比如把输入的链表顺序翻过来倒过去（为了实现正常顺序数字相加），其实就是一个进位的问题，把进位位存下来就好了

参考了一个别人的答案：
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        prenode = ListNode(0)
        lastnode = prenode  # 头结点
        val = 0
        while val or l1 or l2:
            # divmod() 返回商和余数
            val, cur = divmod(val + (l1.val if l1 else 0) + (l2.val if l2 else 0), 10)
            # 每次计算后，将结果作为一个新的结点插入链表尾部
            lastnode.next = ListNode(cur)
            lastnode = lastnode.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return prenode.next
```
这个方案好在使用了链表的头结点，用它作为返回结果，这样就可以在每次运算中顺序在链表后插入新结点

### 结论

- 1. 对于结果要返回链表的程序，使用`头结点`是一个好的选择
- 2. 要活用链表的插入等操作

### 知识点

- 1.`divmod(a, b)`返回a/b的商和余数
- 2.`a // b`结果为a/b的商取整数
- 3.在Python中构建一个链表：
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x       # 数据域
        self.next = None   # 指针域
```

## Problem 3

[题目链接](https://leetcode.com/problems/longest-palindromic-substring/)

一开始没读透`回文(palindromic)`的意思，顺着`Longest Substring Without Repeating Characters`这道题的思路写了。
发现错误之后又经过艰苦卓绝的奋斗，独立搞出来了，而且分数竟然很高（超过90%）：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        '''
        Set a dict, the structure is {char: [index1, index2, ...]}
        When finding a repeated char, check if the string between the same chars is palindromic
        '''
        res_dict = {}
        max_n = max_all = 0
        if len(s) > 0:
            max_s = s[0]
        else:
            return ''
        for index, val in enumerate(s):
            if val not in res_dict:
                res_dict[val] = [index]
            else:
                # add the index into dict
                res_dict[val].append(index)
                for i in range(len(res_dict[val])):
                    max_n = index - res_dict[val][i] + 1
                    cur_s = s[res_dict[val][i]: index+1]
                    if cur_s == cur_s[::-1]:
                        if max_n > max_all:
                            max_all = max_n
                            max_s = cur_s
                        break
        return max_s
```

思路是`找重复字符`，并将相同字符的每一个位置（索引值）存放在一个列表中，并使用`{char: [index1, index2, ...]}`结构的字典来存储，
每当找到重复的字符时，先判断两个最远重复字符（index1）之间的字符串是否为回文，如果不是，再判断第二远重复字符（index2），以此类推，
并在中途记录最长的回文字符串

后来又找了一个答案中最快的程序，研究一下没太懂（但是他比我的快10几倍），先把这个神仙程序记录下来：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) <= 1 or s[::-1] == s:
            return s
        start = 0
        max_len = 1
        
        for i in range(len(s)):
            i_odd = i - max_len -1
            i_even = i - max_len
            odd = s[i_odd:i+1]
            even = s[i_even:i+1]
            print(odd, even)
            if i_odd >= 0 and odd == odd[::-1]:  # 为什么长度要分加1和加2？
                max_len += 2
                start = i_odd
            if i_even >=0 and even == even[::-1]:
                max_len += 1
                start = i_even
        return s[start:start+max_len]
```

### 结论

- 找回文字符串，判断其正反向是否相等是一个好办法

### 知识点

- Python中倒序：通过`[::-1]`的方法，可以处理如字符串和列表等有序的序列，例如：
```python
a = 'abcd'
print(a[::-1])
# 结果为： dcba
```

也可以从中间某一元素开始倒序排列，`[2::-1]`表示从下标为2的元素开始倒序排列，例如：
```python
a = 'abcd'
print(a[2::-1])
# 结果为： cba
```
